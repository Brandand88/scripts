# SPDX-License-Identifier: GPL-3.0-or-later
#
# Copyright (C) 2018-2019 Nathan Chancellor
#
# Functions used to assist with ClangBuiltLinux development


# Universal variables
CBL_SRC=${CBL}/src
CBL_TC=${CBL}/toolchains
CBL_LLVM=${CBL_TC}/llvm-tot/bin
CBL_BNTL=${CBL_TC}/binutils/bin
TCBLD=${CBL}/tc-build
CBL_CCACHE=${CBL}/.ccache
export CBL_SRC CBL_TC CBL_LLVM CBL_BNTL TCBLD CBL_CCACHE


# Configurations known to build with -Werror
CBLCFGS=( "arm:multi_v7_defconfig"
          "arm:allnoconfig"
          "arm:allyesconfig"
          "arm:allyesconfig-be"
          "arm:allmodconfig"
          "arm:allmodconfig-be"
          "arm64:defconfig"
          "arm64:allnoconfig"
          "arm64:allyesconfig"
          "arm64:allyesconfig-be"
          "arm64:allmodconfig"
          "arm64:allmodconfig-be"
          "mipsel:malta_defconfig"
          "ppc32:ppc44x_defconfig"
          "ppc32:allnoconfig"
          "ppc64:pseries_defconfig"
          "ppc64:allnoconfig"
          "ppc64le:powernv_defconfig"
          "x86:defconfig"
          "x86:allyesconfig"
          "x86:allmodconfig" )


# Create build folders
function crbf() {
    local ITEM
    for ITEM in binutils kernel llvm; do
        export "$(echo ${ITEM:0:1} | tr '[:lower:]' '[:upper:]')BF=${BLDF}/${ITEM}"
        mkdir -p "${BLDF}/${ITEM}"
    done
}


# Patch check function
function pch() {(
    [[ ${#} -eq 0 ]] && FP_PARAMS=( -1 HEAD )
    [[ -z ${FP_PARAMS[*]} ]] && FP_PARAMS=( "${@}" )
    [[ -f scripts/checkpatch.pl ]] && git fp --stdout "${FP_PARAMS[@]}" | ./scripts/checkpatch.pl
    [[ -f scripts/get_maintainer.pl ]] && git fp --stdout "${FP_PARAMS[@]}" | ./scripts/get_maintainer.pl --scm
)}


# Quilt-like patch management function for Linux
function ptchmn() {(
    [[ ! -f Makefile ]] && die "You're not in a kernel folder!"

    TARGET_FOLDER=${GITHUB_FOLDER}/patches/${PWD##*/}/$(git cb)
    [[ ! -d ${TARGET_FOLDER} ]] && die "${TARGET_FOLDER} doesn't exist!"

    case ${PWD##*/} in
        "linux") UPSTREAM=master ;;
        "linux-next") UPSTREAM=stable ;;
        *) die "${PWD##*/} not supported by ptchmn!"
    esac

    case "${1:?}" in
        "-s"|"--sync")
            FIRST_HASH=$(git log --reverse --format=%H --committer="$(git config --get user.name) <$(git config --get user.email)>" origin/"${UPSTREAM}"..HEAD | head -n1)
            [[ -z ${FIRST_HASH} ]] && die "FIRST_HASH is empty...?"

            rm "${TARGET_FOLDER}"/*

            git fp -o "${TARGET_FOLDER}" "${FIRST_HASH}"^..HEAD

            git -C "${TARGET_FOLDER}" aa

            git -C "${TARGET_FOLDER}" c -m "patches: linux: $(git cb): Sync as of $(git sh -s --format=%h)"

            git -C "${TARGET_FOLDER}" push ;;

        "-a"|"--apply")
            git am "${TARGET_FOLDER}"/* ;;
    esac
)}


# Rebase a linux-next branch
function rbln() {(
    [[ ! -f Makefile ]] && { display_error "You're not in a kernel folder!"; return 1; }
    FIRST_HASH=$(git log --reverse --format=%H --committer="$(git config --get user.name) <$(git config --get user.email)>" origin/stable..HEAD | head -n1)
    SECOND_HASH=$(git show -s --format=%H "$(git cb)")
    git rh origin/master
    git cherry-pick --gpg-sign "${FIRST_HASH}^..${SECOND_HASH}"
)}


# Download and apply an LLVM/Clang/lld patch
function phabap() {(
    [[ ! -d llvm ]] && die "You're not in the llvm-project folder!"

    REVISION=${1:?}
    [[ ${#} -ge 1 ]] && shift

    curl -LSs "https://reviews.llvm.org/${REVISION}?download=true" | git ap "${@}" || exit ${?}
    git ac -m "${REVISION}

Link: https://reviews.llvm.org/${REVISION}"
)}


# Call ccache
function ccache_call() {
    header "${CCACHE_DIR:?}"
    [[ -d ${CCACHE_DIR} ]] && mkdir -p "${CCACHE_DIR}"
    ccache "${@}"
}


# Work with multiple ccache folders
function ccache_for_all() {(
    while (( ${#} )); do
        case ${1} in
            "binutils"|"kernel"|"llvm") CCACHE_DIR="${CBL_CCACHE}"/${1} ;;
            "clear") CCACHE_OPTS=( --clear --zero-stats ) ;;
            "stats") CCACHE_OPTS=( --show-stats ) ;;
        esac
        shift
    done

    if [[ -z ${CCACHE_DIR} ]]; then
        for CCACHE_DIR in "${CBL_CCACHE}"/*; do
            export CCACHE_DIR
            ccache_call "${CCACHE_OPTS[@]}"
        done
    else
        export CCACHE_DIR
        ccache_call "${CCACHE_OPTS[@]}"
   fi
)}


# Print specific folder ccache stats
function ccache_stats() {(
    ccache_for_all stats "${@}"
)}


# Clear specific folder ccache
function ccache_clear() {(
    ccache_for_all clear "${@}"
)}


# Create ccache at specific size
function ccache_size() {
    while (( ${#} )); do
        case ${1} in
            "binutils"|"kernel"|"llvm") CCACHE_DIR="${CBL_CCACHE}"/${1} ;;
            *) SIZE=${1} ;;
        esac
        shift
    done
    export CCACHE_DIR
    ccache_call --max-size="${SIZE:?}"G >/dev/null
    ccache --set-config=compression=true
    ccache --set-config=compression_level=9
}


# Build kernel with Clang (wrapper)
function bldkw() {(
    if [[ ! -f Makefile ]]; then
        display_error "No Makefile found! Are you in a kernel tree?"
        return
    fi

    TARGET_ARCH=${1}; shift
    case "${TARGET_ARCH}" in
        "arm") MAKE_FLAGS=( "ARCH=arm" "CROSS_COMPILE=${CROSS_COMPILE:-arm-linux-gnueabi-}" ) ;;
        "arm64") MAKE_FLAGS=( "ARCH=arm64" "CROSS_COMPILE=${CROSS_COMPILE:-aarch64-linux-gnu-}" ) ;;
        "mipsel") MAKE_FLAGS=( "ARCH=mips" "CROSS_COMPILE=${CROSS_COMPILE:-mipsel-linux-gnu-}" ) ;;
        "ppc32") MAKE_FLAGS=( "ARCH=powerpc" "CROSS_COMPILE=${CROSS_COMPILE:-powerpc-linux-gnu-}" ) ;;
        "ppc64") MAKE_FLAGS=( "ARCH=powerpc" "CROSS_COMPILE=${CROSS_COMPILE:-powerpc64-linux-gnu-}" ) ;;
        "ppc64le") MAKE_FLAGS=( "ARCH=powerpc" "CROSS_COMPILE=${CROSS_COMPILE:-powerpc64le-linux-gnu-}" ) ;;
        "x86") MAKE_FLAGS=() ;;
        *) display_error "Invalid TARGET_ARCH specified!"; return ;;
    esac

    # We are only concerned about little endian for ARM right now unless otherwise stated
    if [[ ${TARGET_ARCH} =~ arm && -z ${BE} ]]; then
        KCONFIG_ALLCONFIG=${KBF}/little-endian.config
        echo "CONFIG_CPU_BIG_ENDIAN=n" > "${KCONFIG_ALLCONFIG}"
    fi

    # Use our versions of Clang
    move_to_front_of_path "${CBL_BNTL}"
    move_to_front_of_path "${CBL_LLVM}"
    [[ -n ${PO} ]] && move_to_front_of_path "${PO}"

    if [[ ${Q} -ne 2 ]]; then
        echo
        echo "${BOLD}LLVM location:${RST} $(dirname "$(command -v clang)")"
        echo
    fi

    # Setup ccache
    ccache_size kernel 100

    # Build the kernel
    set -x
    make ${Q:+-s} \
         "${JOBS_FLAG}" \
         AR="${AR:-llvm-ar}" \
         CC="${CC:-${CCACHE} clang}" \
         ${KCONFIG_ALLCONFIG:+KCONFIG_ALLCONFIG="${KCONFIG_ALLCONFIG}"} \
         HOSTCC="${HOSTCC:-${CCACHE} clang}" \
         HOSTCXX="${HOSTCXX:-${CCACHE} clang++}" \
         HOSTLD="${HOSTLD:-ld.lld}" \
         HOSTLDFLAGS="${HOSTLDFLAGS--fuse-ld=lld}" \
         "${MAKE_FLAGS[@]}" \
         NM="${NM:-llvm-nm}" \
         O="${O:-${KBF}}" \
         OBJDUMP="${OBJDUMP:-llvm-objdump}" \
         STRIP="${STRIP:-llvm-strip}" \
         "${@}"
    EXIT_CODE=${?}
    set +x
    exit ${EXIT_CODE}
)}


# Configure and build a kernel with Clang
function bldk() {(
    # Parameters
    while (( ${#} )); do
        case ${1} in
            *config) CONFIG=${1} ;;
            arm|arm64|mipsel|ppc32|ppc64|ppc64le|x86) ARCH=${1} ;;
            KCFLAGS=*|V=*|W=*) BLDKW_ARGS+=( "${1}" ) ;;
            *.o|*/*|all|vmlinux|modules|*Image*) TARGETS+=( "${1}" ) ;;
        esac

        shift
    done

    # Sanity checks
    [[ -z ${ARCH} ]] && die "ARCH not specified!"
    if [[ -z ${CONFIG} ]]; then
        case ${ARCH} in
            "mipsel") CONFIG=malta_defconfig ;;
            "ppc32") CONFIG=ppc44x_defconfig ;;
            "ppc64") CONFIG=pseries_defconfig ;;
            "ppc64le") CONFIG=powernv_defconfig ;;
            *) CONFIG=defconfig ;;
        esac
    fi
    [[ ${PWD} =~ cbl && ${CONFIG} =~ defconfig ]] && CBL_DEFCONFIG=true

    if ${CBL_DEFCONFIG:=false}; then
        # Use lld by default for everything but certain PowerPC builds
        if [[ -z ${LD} ]]; then
            case ${ARCH} in
                "mipsel"|"ppc64") ;;
                *) LD=ld.lld ;;
            esac
        fi

        # Use llvm-objcopy
        [[ -z ${OBJCOPY} ]] && OBJCOPY=llvm-objcopy
    fi

    BLDKW=( bldkw "${ARCH}" ${LD:+LD="${LD}"} ${OBJCOPY:+OBJCOPY="${OBJCOPY}"} )
    [[ -n ${BLDKW_ARGS[*]} ]] && BLDKW+=( "${BLDKW_ARGS[@]}" )

    # Configure kernel
    "${BLDKW[@]}" distclean "${CONFIG}"

    : ${O:=${KBF}}
    if ${CBL_DEFCONFIG:?}; then
        # Extra configs for build/boot testings
        # From https://github.com/groeck/linux-build-test/blob/master/rootfs/scripts/common.sh
        echo "CONFIG_INIT_STACK_ALL=y
CONFIG_EXPERT=y
CONFIG_DEBUG_KERNEL=y
CONFIG_LOCK_DEBUGGING_SUPPORT=y
CONFIG_DEBUG_RT_MUTEXES=y
CONFIG_DEBUG_SPINLOCK=y
CONFIG_DEBUG_MUTEXES=y
CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y
CONFIG_DEBUG_LOCK_ALLOC=y
CONFIG_DEBUG_LOCKDEP=y
CONFIG_DEBUG_ATOMIC_SLEEP=y
CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
CONFIG_CRC32_SELFTEST=y
CONFIG_DEBUG_LOCKING_API_SELFTESTS=y
CONFIG_DEBUG_NMI_SELFTEST=y
CONFIG_DEBUG_RODATA_TEST=y
CONFIG_DEBUG_TLBFLUSH=y
CONFIG_DMATEST=y
CONFIG_GLOB_SELFTEST=y
CONFIG_PCI_EPF_TEST=y
CONFIG_PCI_ENDPOINT_TEST=y
CONFIG_PROVE_LOCKING=y
CONFIG_PROVE_RCU=y
CONFIG_RBTREE_TEST=y
CONFIG_RCU_EQS_DEBUG=y
CONFIG_STATIC_KEYS_SELFTEST=y
CONFIG_STRING_SELFTEST=y
CONFIG_TEST_BITMAP=y
CONFIG_TEST_FIRMWARE=y
CONFIG_TEST_SORT=y
CONFIG_TEST_SYSCTL=y
CONFIG_TEST_UUID=y
CONFIG_TORTURE_TEST=y
CONFIG_USB_TEST=y
CONFIG_USB_EHSET_TEST_FIXTURE=y
CONFIG_USB_LINK_LAYER_TEST=y
CONFIG_WW_MUTEX_SELFTEST=y
CONFIG_BLK_DEV_INITRD=y
CONFIG_DEVTMPFS=y
CONFIG_DEVTMPFS_MOUNT=y
CONFIG_SCSI=y
CONFIG_BLK_DEV_SD=y
CONFIG_SCSI_LOWLEVEL=y
CONFIG_SCSI_DC395x=y
CONFIG_SCSI_AM53C974=y
CONFIG_SCSI_SYM53C8XX_2=y
CONFIG_MEGARAID_SAS=y
CONFIG_FUSION=y
CONFIG_FUSION_SAS=y
CONFIG_MMC=y
CONFIG_MMC_SDHCI=y
CONFIG_MMC_SDHCI_PCI=y
CONFIG_BLK_DEV_NVME=y
CONFIG_USB=y
CONFIG_USB_XHCI_HCD=y
CONFIG_USB_EHCI_HCD=y
CONFIG_USB_OHCI_HCD=y
CONFIG_USB_STORAGE=y
CONFIG_USB_UAS=y
CONFIG_VIRTIO=y
CONFIG_VIRTIO_PCI=y
CONFIG_VIRTIO_PCI_LEGACY=y
CONFIG_VIRTIO_BALLOON=y
CONFIG_VIRTIO_MMIO=y
CONFIG_BLK_MQ_VIRTIO=y
CONFIG_VIRTIO_BLK=y
CONFIG_VIRTIO_BLK_SCSI=y
CONFIG_SCSI_VIRTIO=y" >> "${O}"/.config

        [[ ${ARCH} =~ arm ]] && echo "CONFIG_LOCK_TORTURE_TEST=y
CONFIG_RCU_TORTURE_TEST=y" >> "${O}"/.config

        "${BLDKW[@]}" olddefconfig &>/dev/null
    fi

    # Build kernel
    [[ -z ${TARGETS[*]} ]] && TARGETS=( all )
    grep -q "CONFIG_MODULES=y" ${O:?}/.config && TARGETS=( modules_prepare "${TARGETS[@]}" )
    "${BLDKW[@]}" "${TARGETS[@]}"
)}


# Download EFI firmware
function download_efi_firmware() {(
    AAVMF=${HOME}/usr/share/AAVMF
    AAVMF_FILES=( AAVMF_CODE.fd AAVMF_VARS.fd )
    AAVMF_DEB=qemu-efi-aarch64_0~20190606.20d2e5a1-2_all.deb

    OVMF=${HOME}/usr/share/OVMF
    OVMF_FILES=( OVMF_CODE.fd OVMF_VARS.fd )
    OVMF_DEB=ovmf_0~20190606.20d2e5a1-2_all.deb

    cd "$(mktemp -d)"
    rm -rf "${AAVMF}"
    mkdir -p "${AAVMF}"
    curl -LSsO http://ftp.us.debian.org/debian/pool/main/e/edk2/"${AAVMF_DEB}"
    ar x "${AAVMF_DEB}"
    tar xJf data.tar.xz
    for AAVMF_FILE in "${AAVMF_FILES[@]}"; do
        mv "${AAVMF//${HOME}\/}"/"${AAVMF_FILE}" "${AAVMF}"
    done

    cd "$(mktemp -d)"
    rm -rf "${OVMF}"
    mkdir -p "${OVMF}"
    curl -LSsO http://http.us.debian.org/debian/pool/main/e/edk2/"${OVMF_DEB}"
    ar x "${OVMF_DEB}"
    tar xJf data.tar.xz
    for OVMF_FILE in "${OVMF_FILES[@]}"; do
        mv "${OVMF//${HOME}\/}"/"${OVMF_FILE}" "${OVMF}"
    done
)}


# Boot a kernel in QEMU
function bootk() {(
    ARCH=${1}; shift
    [[ -z ${ARCH} ]] && die "ARCH not specified!"

    IMAGES_FOLDER=${CBL}/git/ci-master/images
    [[ ! -d ${IMAGES_FOLDER} ]] && die "${IMAGES_FOLDER} doesn't exist!"

    case ${ARCH} in
        "arm")
            IMAGE=zImage
            QEMU=qemu-system-arm
            QEMU_ARCH_CMDLINE=( -machine virt
                                -no-reboot
                                -drive "file=${IMAGES_FOLDER}/arm/rootfs.ext4,format=raw,id=rootfs,if=none"
                                -device "virtio-blk-device,drive=rootfs"
                                -append "console=ttyAMA0 root=/dev/vda ${QEMU_CMDLINE}" ) ;;
        "arm64")
            IMAGE=Image.gz
            QEMU=qemu-system-aarch64
            QEMU_ARCH_CMDLINE=( -cpu cortex-a57
                                -drive "file=${IMAGES_FOLDER}/arm64/rootfs.ext4,format=raw,id=rootfs,if=none"
                                -device "virtio-blk-device,drive=rootfs"
                                -append "console=ttyAMA0 earlycon root=/dev/vda ${QEMU_CMDLINE}" ) ;;
        "mipsel")
            IMAGE=vmlinux
            QEMU=qemu-system-mipsel
            QEMU_ARCH_CMDLINE=( -machine malta
                                -cpu 24Kf
                                -append "root=/dev/sda ${QEMU_CMDLINE}"
                                -drive "file=${IMAGES_FOLDER}/mipsel/rootfs.ext4,format=raw,if=ide" ) ;;
        "ppc32")
            IMAGE=zImage
            RAM=128m
            QEMU=qemu-system-ppc
            QEMU_ARCH_CMDLINE=( -machine bamboo
                                -append "console=ttyS0 ${QEMU_CMDLINE}"
                                -no-reboot
                                -initrd "${IMAGES_FOLDER}/ppc32/rootfs.cpio" )
            ARCH=powerpc ;;
        "ppc64")
            IMAGE=vmlinux
            RAM=1G
            QEMU=qemu-system-ppc64
            QEMU_ARCH_CMDLINE=( -machine pseries
                                -vga none
                                -initrd "${IMAGES_FOLDER}/ppc64/rootfs.cpio" )
            ARCH=powerpc ;;
        "ppc64le")
            IMAGE=zImage.epapr
            RAM=2G
            QEMU=qemu-system-ppc64
            QEMU_ARCH_CMDLINE=( -machine powernv
                                -device "ipmi-bmc-sim,id=bmc0"
                                -device "isa-ipmi-bt,bmc=bmc0,irq=10"
                                -L /usr/share/qemu -bios skiboot.lid
                                -initrd "${IMAGES_FOLDER}/ppc64le/rootfs.cpio"
                                ${QEMU_CMDLINE:+-append "${QEMU_CMDLINE}"} )
            ARCH=powerpc ;;
        "x86")
            IMAGE=bzImage
            QEMU=qemu-system-x86_64
            QEMU_ARCH_CMDLINE=( -append "console=ttyS0 earlycon root=/dev/vda ${QEMU_CMDLINE}"
                                -cpu host
                                -d unimp,guest_errors
                                -drive "file=${IMAGES_FOLDER}/x86_64/rootfs.ext4,format=raw,if=virtio"
                                -enable-kvm ) ;;
        *) die "Invalid ARCH specified!" ;;
    esac

    [[ ${IMAGE} = "vmlinux" ]] || BOOT_FOLDER=arch/${ARCH}/boot/
    KERNEL=${O:-${KBF}}/${BOOT_FOLDER:+${BOOT_FOLDER}}${IMAGE}
    [[ -f ${KERNEL} ]] || die "Kernel doesn't exist! Please build one."
    if [[ ! "$(readlink -f ${KERNEL})" =~ common ]]; then
        [[ -d ${HOME}/usr/share/AAVMF && -d ${HOME}/usr/share/OVMF ]] || download_efi_firmware
        case ${ARCH} in
            "arm64")
                QEMU_ARCH_CMDLINE+=( -drive "if=pflash,format=raw,readonly,file=${HOME}/usr/share/AAVMF/AAVMF_CODE.fd"
                                     -drive "if=pflash,format=raw,file=${HOME}/usr/share/AAVMF/AAVMF_VARS.fd" ) ;;
            "x86")
                QEMU_ARCH_CMDLINE+=( -drive "if=pflash,format=raw,readonly,file=${HOME}/usr/share/OVMF/OVMF_CODE.fd"
                                     -drive "if=pflash,format=raw,file=${HOME}/usr/share/OVMF/OVMF_VARS.fd" ) ;;
        esac
    fi

    # Update the images
    git -C "${IMAGES_FOLDER}" rh --quiet
    git -C "${IMAGES_FOLDER}" pull --quiet --rebase

    # Print or run the command
    COMMAND=( "${QEMU}" "${QEMU_ARCH_CMDLINE[@]}" -kernel "${KERNEL}" -m "${RAM:-512m}" -display none -serial mon:stdio )
    [[ -z ${NO_TIMEOUT} ]] && COMMAND=( timeout 2m unbuffer "${COMMAND[@]}" )

    set -x
    case ${ARCH} in
        "arm64")
            "${COMMAND[@]}" -machine virt "${@}"
            "${COMMAND[@]}" -machine "virt,virtualization" "${@}" ;;
        *)
            "${COMMAND[@]}" "${@}" ;;
    esac
    EXIT_CODE=${?}
    set +x
    exit ${EXIT_CODE}
)}


# Build a kernel and boot it
function babk() {(
    ARCH=${1}; shift
    [[ -z ${ARCH} ]] && die "ARCH not specified!"

    bldk "${ARCH}" KCFLAGS="${KCFLAGS--Werror}" "${@}"

    bootk "${ARCH}"
)}


# Show local LLVM patches via git log
function llvm_log() {(
    cd "${TCBLD:?}"/llvm-project || return
    MFC=$(git log --reverse --format=%H --committer="$(git config --get user.name) <$(git config --get user.email)>" --since="$(date --date="1 week ago")" | head -n1)
    if [[ -n ${MFC} ]]; then
        echo
        echo "LLVM commit log:"
        echo
        git lo ${MFC}^^..HEAD
    fi
)}


# linux testing
function lt() {(
    cd "${CBL}"/"${TREE:=linux-next}" || die "wtf"

    while (( ${#} )); do
        case ${1} in
            # defconfig + little-endian allyesconfig
            "-b"|"--basic") BASIC=true ;;
            "-d"|"--debug") DEBUG=true ;;
            # Show non-fatal warnings
            "-w"|"--warnings") SHOW_NF_WARNINGS=true ;;
        esac
        shift
    done

    # Logging
    LOG_DIR=$(mktemp -d)
    LOG=${LOG_DIR}/main.log
    echo
    echo "Build log: ${LOG}"
    echo
    {
        (
            path_push "${CBL_BNTL}"
            path_push "${CBL_LLVM}"
            [[ -n ${PO} ]] && path_push "${PO}"
            echo "clang location: $(command -v clang)"
            echo
            clang --version | head -n1
        )
        echo
        echo "Version: $(make -s O=out alldefconfig &>/dev/null && make -s O=out kernelrelease && rm -rf out)"
        echo
        echo "Build results:"
        echo
    } > "${LOG}"

    for CONFIG in "${CBLCFGS[@]}"; do (
        ARCH=${CONFIG%%:*}
        CONFIG=${CONFIG##*:}

        # Basic configs are defconfigs + little endian allyesconfig
        [[ -n ${BASIC} && ! ( ${CONFIG} =~ defconfig || ${CONFIG} = "allyesconfig" ) ]] && continue

        header "${ARCH}:${CONFIG}"

        # Start timer
        START=$(date +%s)

        # Warning/error log
        WARNING_LOG=${LOG_DIR}/${ARCH}_${CONFIG}.log

        # Make sure CONFIG_CPU_BIG_ENDIAN gets set
        [[ ${CONFIG} =~ -be ]] && export BE=true
        CONFIG=${CONFIG//-be}

        # Use lld by default for everything but certain PowerPC builds
        if [[ -z ${LD} && -z ${BE} ]]; then
            case "${ARCH}:${CONFIG}" in
                mipsel*|ppc64*) ;;
                *) LD=ld.lld ;;
            esac
        fi

        # Use llvm-objcopy
        [[ -z ${OBJCOPY} ]] && OBJCOPY=llvm-objcopy

        # Build kernel silently normally
        if [[ -z ${DEBUG} ]]; then
            Q=2 bldk "${ARCH}" "${CONFIG}" KCFLAGS="${KCFLAGS--Werror}" ${LD:+LD="${LD}"} ${OBJCOPY:+OBJCOPY="${OBJCOPY}"} |& tee "${WARNING_LOG}"
            MAKE_RESULT=${pipestatus[1]}
        else
            bldk "${ARCH}" "${CONFIG}" KCFLAGS="${KCFLAGS--Werror}" ${LD:+LD="${LD}"} ${OBJCOPY:+OBJCOPY="${OBJCOPY}"}
            MAKE_RESULT=${?}
        fi

        # Make sure that if make fails, it gets propgated to the if statement
        if [[ ${MAKE_RESULT} -eq 0 ]]; then
            COLOR=${GRN}
            RESULT=successful
        else
            COLOR=${RED}
            RESULT=failed
        fi
        echo "${COLOR}Build ${RESULT}${RST}"
        TIME_STRING=$(format_time "${START}" "$(date +%s)")
        {
            echo "${ARCH}:${CONFIG}${BE:+"-be"} | Build ${RESULT} in ${TIME_STRING:l}\c"
            if [[ ${RESULT} = "successful" && ${CONFIG} =~ defconfig ]]; then
                if bootk "${ARCH}" &>/dev/null; then
                    echo " | Boot successful\c"
                else
                    echo " | Boot failed\c"
                fi
            fi
            echo
            [[ -z ${DEBUG} && ( -n ${SHOW_NF_WARNINGS} || ${RESULT} = "failed" ) ]] && \
                rg --color=never "error:|warning:|undefined" "${WARNING_LOG}" | sed "s/${PWD//\//\\/}\///g"
            echo
        } >> "${LOG}"
    ) done

    {
        echo "${TREE} commit log:"
        echo
        git lo $(git log --reverse --format=%H --committer="$(git config --get user.name) <$(git config --get user.email)>" --since="$(date --date="1 week ago")" | head -n1)^^..HEAD
        llvm_log
    } >> "${LOG}"

    MESSAGE="linux$([[ -f localversion-next ]] && cat localversion-next) build results: $(deldog "${LOG}")"

    tg_msg "${MESSAGE}"

    echo
    echo "${MESSAGE}"
    echo

    rm "${LOG}"
)}


# Pull the latest CBL Docker image and run it with podman
function pdmnrn() {(
    [[ -z ${PODMAN_IMAGE} ]] && PODMAN_IMAGE=clangbuiltlinux/debian
    [[ -z ${LOCAL} ]] && podman pull "${PODMAN_IMAGE}"
    podman_mount --interactive \
                 --rm \
                 --tty \
                 "${PODMAN_IMAGE}" "${@}"
)}


# Strip LLVM binaries
function stripllvmbin() {(
    BINARIES_TO_STRIP=( clang lld llvm-ar llvm-pdbutil llvm-symbolizer llvm-undname sancov )
    for BINARY in "${BINARIES_TO_STRIP[@]}"; do strip "${1:?}"/bin/"${BINARY}"; done
)}


# Build LLVM
function bldllvm() {(
    # Setup ccache
    ccache_size llvm 75

    "${TCBLD}"/build-llvm.py "${@}"
)}


# Build binutils
function bldbn() {(
    # Setup ccache
    ccache_size binutils 25

   "${TCBLD}"/build-binutils.py "${@}"
)}


# Build LLVM/Clang/lld and arm{32,64} and powerpc binutils from source
function bldusr() {(
    rm -rf "${INSTALL_FOLDER:=${CBL_USR}}"

    # Build binutils
    CBL_BNTL=${CBL_BNTL%/*}
    rm -rf "${CBL_BNTL}"-old
    mv "${CBL_BNTL}" "${CBL_BNTL}"-old
    bldbn --build-folder "${BBF:?}" \
          --install-folder "${CBL_BNTL}" \
          --update || die "bldbn failed with exit code ${?}"

    # Build LLVM/Clang/lld
    CBL_LLVM=${CBL_LLVM%/*}
    rm -rf "${CBL_LLVM}"-old
    mv "${CBL_LLVM}" "${CBL_LLVM}"-old
    bldllvm --build-folder "${LBF:?}" \
            --check-targets lld clang llvm \
            --install-folder "${CBL_LLVM}" \
            --lto=thin \
            --march=native \
            --pgo \
            --update-llvm || die "bldllvm failed with exit code ${?}"
    stripllvmbin "${INSTALL_FOLDER}"

    # Invalidate our kernel ccache because we have a new compiler that will be used for it
    ccache_clear kernel
)}


# kernel/common build wrapper
function kcbw() {(
    BUILD_FOLDER=${CBL}/android/build
    COMMON_FOLDER=${CBL}/android/common
    OUT_FOLDER=${BLDF}/common

    while (( ${#} )); do
        case ${1} in
            arm64|x86) ARCH=${1} ;;
            CC=*|LD=*) export "${1:?}" ;;
            3.*|4.*) BRANCH=${1} ;;
        esac
        shift
    done

    BRANCH=android-${BRANCH:-4.9}
    [[ -z ${LD} && ${BRANCH} = "android-4.19" ]] && LD=ld.lld

    cd "${BUILD_FOLDER}" || die "wtf"

    echo 'ARCH='"${ARCH:=arm64}"'
BRANCH='"${BRANCH}"'
'$(if [[ ${ARCH} = arm64 ]]; then
    echo "CLANG_TRIPLE=aarch64-linux-gnu-
CROSS_COMPILE=${CROSS_COMPILE:-"aarch64-linux-gnu-"}"
fi)'
DEFCONFIG='"$([[ ${ARCH} = "x86" ]] && echo "x86_64_")"'cuttlefish_defconfig
EXTRA_CMDS='\'''\''
KERNEL_DIR='"$(realpath --relative-to="${PWD}" "${COMMON_FOLDER}")"'
POST_DEFCONFIG_CMDS="check_defconfig && update_clang_config"
CLANG_PREBUILT_BIN='"$(realpath --relative-to="${PWD}" "${CPB:-${CBL_LLVM}}")"'
LD_LIBRARY_PATH='"${LD_LIBRARY_PATH:-"${CBL_USR}"/lib}"'
LINUX_GCC_CROSS_COMPILE_PREBUILTS_BIN='"$(realpath --relative-to="${PWD}" "${GCCPB:-${CBL_BNTL}}")"'
FILES="
arch/'"${ARCH}"'/boot/'$(case ${ARCH} in arm64) echo "Image.gz" ;; x86) echo "bzImage" ;; esac)'
vmlinux
System.map
"
STOP_SHIP_TRACEPRINTK=1

function update_clang_config() {
  ${KERNEL_DIR}/scripts/config --file ${OUT_DIR}/.config \
    -e JUMP_LABEL \
    -e LTO_CLANG \
    -e CFI_CLANG \
    --set-val FRAME_WARN 2048
  (cd ${KERNEL_DIR} && \
    make O=${OUT_DIR} ${CC_LD_ARG} olddefconfig)
}' > "${BUILD_CONFIG:=$(mktemp)}"

    # Make path relative
    BUILD_CONFIG=$(realpath --relative-to="${PWD}" "${BUILD_CONFIG}")

    # Make sure that we are on the correct branch
    (
        cd "${COMMON_FOLDER}" || return
        git ch "${BRANCH}" || { git rh -q && git ch "${BRANCH}"; }
        git pull --rebase
    )

    OUT_DIR=${OUT_FOLDER} BUILD_CONFIG=${BUILD_CONFIG} CC="${CC:-clang}" KCFLAGS="${KCFLAGS}" LD="${LD}" ./build.sh "${@}"
)}


# kernel/common build testing
function kct() {(
    COMMON_FOLDER=${CBL}/android/common
    OUT_FOLDER=${BLDF}/common

    while (( ${#} )); do
        case ${1} in
            "-d"|"--debug") DEBUG=true ;;
            # Show non-fatal warnings
            "-w"|"--warnings") SHOW_NF_WARNINGS=true ;;
        esac
        shift
    done

    # Logging
    LOG=$(mktemp)
    echo
    echo "Build log: ${LOG}"
    echo
    {
        (
            path_push "${CBL_BNTL}"
            path_push "${CBL_LLVM}"
            [[ -n ${CPB} ]] && path_push "${CPB}"
            echo "clang location: $(command -v clang)"
            echo
            clang --version | head -n1
            llvm_log
            echo
            echo "Build results:"
            echo
        )
    } > "${LOG}"

    for VERSION in 4.9 4.14 4.19; do (
        START=$(date +%s)

        # Error log
        ERRORS=$(mktemp)

        # Build kernel silently normally
        if [[ -z ${DEBUG} ]]; then
            KCFLAGS="${KCFLAGS--Werror}" kcbw arm64 "${VERSION}" |& \
            rg --color=never "error:|warning:|undefined" |& sed "s/${COMMON_FOLDER//\//\\/}\///g" > "${ERRORS}"
            MAKE_RESULT=${pipestatus[1]}
        else
            KCFLAGS="${KCFLAGS--Werror}" kcbw arm64 "${VERSION}"
            MAKE_RESULT=${?}
        fi

        # Make sure that if make fails, it gets propgated to the if statement
        if [[ ${MAKE_RESULT} -eq 0 ]]; then
            RESULT=successful
        else
            RESULT=failed
        fi
        TIME_STRING=$(format_time "${START}" "$(date +%s)")
        {
            echo "android-${VERSION} | $(cd "${COMMON_FOLDER}" || die "wtf"; git kf origin/"$(git cb)") | Build ${RESULT} in ${TIME_STRING:l}\c"
            if [[ ${RESULT} = "successful" ]]; then
                if O=${OUT_FOLDER} bootk arm64 &>/dev/null; then
                    echo " | Boot successful\c"
                else
                    echo " | Boot failed\c"
                fi
            fi
            echo
            [[ -z ${DEBUG} && ( -n ${SHOW_NF_WARNINGS} || ${RESULT} = "failed" ) ]] && cat "${ERRORS}"
            echo
        } >> "${LOG}"
        rm "${ERRORS}"
    ) done

    MESSAGE="kernel/common build results: $(deldog "${LOG}")"

    tg_msg "${MESSAGE}"

    echo
    echo "${MESSAGE}"
    echo

    rm "${LOG}"

)}


# Build all kernel trees
function bldallk() {(
    TREE=linux lt
    TREE=linux-next lt
    kct
)}


# Build new LLVM/Clang/lld and test all kernel trees
function bldall() {(
    export TG=true
    bldusr && bldallk
)}


# Function to test build-{binutils,llvm}.py in multiple Docker images
function bld_llvm_bntls_py() {(
    CCACHE_FOLDER=${CBL}/git/ccache
    LOG=$(mktemp); echo "Log: ${LOG}"
    SCRIPT=$(mktemp --suffix=.sh)
    TC_BLD=${CBL}/git/tc-build

    mkdir -p "${CCACHE_FOLDER}"
    cd "${TC_BLD}" || die "Could not move into ${TC_BLD}!"
    [[ -f build-llvm.py ]] || die "build-llvm.py script could not be found!"

    echo '#!/usr/env/bash

PACKAGES=( ccache clang cmake git python3 )

# Debian/Ubuntu
if command -v apt-get &>/dev/null; then
    PACKAGES+=( ca-certificates curl file gcc g++ make ninja-build texinfo zlib1g-dev )
    case "$(cat /etc/os-release)" in
        *buster*|*bionic*|*cosmic*|*disco*) PACKAGES+=( lld ) ;;
    esac
    apt-get update
    apt-get upgrade -y
    apt-get install --no-install-recommends -y "${PACKAGES[@]}"
# Fedora
elif command -v dnf &>/dev/null; then
    PACKAGES+=( gcc gcc-c++ lld make ninja-build zlib-devel )
    dnf update -y
    dnf install -y "${PACKAGES[@]}"
# Arch
elif command -v pacman &>/dev/null; then
    PACKAGES+=( base-devel lld ninja )
    pacman -Syyu --noconfirm
    pacman -S --noconfirm "${PACKAGES[@]}"
# OpenSUSE Leap/Tumbleweed
elif command -v zypper &>/dev/null; then
    PACKAGES+=( curl gcc gcc-c++ gzip lld make ninja tar zlib-devel )
    zypper -n up
    zypper -n in "${PACKAGES[@]}"
fi

ccache -M 50G
ccache --set-config=compression=true
ccache --set-config=compression_level=9
ccache --set-config=cache_dir=/ccache

git clone /'"${PWD##*/}"' /'"${PWD##*/}"'2 && cd /'"${PWD##*/}"'2

./build-binutils.py -t all || exit 1
CC=gcc ./build-llvm.py || exit 1
CC=clang ./build-llvm.py || exit 1

for FILE in clang ld.lld aarch64-linux-gnu-ld arm-linux-gnueabi-ld mipsel-linux-gnu-ld powerpc64le-linux-gnu-ld powerpc-linux-gnu-ld powerpc64-linux-gnu-ld ld; do
    ./install/bin/${FILE} --version || exit 1
done' > "${SCRIPT}"

    for IMAGE in archlinux/base:latest \
                 debian:stable-slim \
                 debian:testing-slim \
                 debian:unstable-slim \
                 fedora:latest \
                 fedora:rawhide \
                 opensuse/leap:latest \
                 opensuse/tumbleweed:latest \
                 ubuntu:xenial \
                 ubuntu:latest \
                 ubuntu:rolling \
                 ubuntu:devel; do
        podman pull "${IMAGE}"
        podman_mount --interactive \
                     --mount type=bind,source="${CCACHE_FOLDER}",target=/ccache \
                     --mount type=bind,source="${SCRIPT}",target=/script.sh \
                     --rm \
                     --tty \
                     "${IMAGE}" bash /script.sh || { echo "${IMAGE} failed" >> "${LOG}"; continue; }
        echo "${IMAGE} successful" >> "${LOG}"
    done

    echo
    echo "Results:"
    cat "${LOG}"
    tg_msg "$(cat "${LOG}")"
    echo
)}


function yapf() {
    PYTHONPATH=${CBL}/git/yapf python3 ${CBL}/git/yapf/yapf -i -p "${@}"
}


function qualify_tc_bld_uprev() {(
    TC_BLD=${HOME}/cbl/git/tc-build

    cd "$(mktemp -d)"

    "${TC_BLD}"/build-binutils.py --install-folder "${PWD}"

    "${TC_BLD}"/build-llvm.py --install-folder "${PWD}" --use-good-revision --check-targets lld clang llvm

    PATH=${PWD}/bin:${PATH} clang --version

    git -C "${TC_BLD}"/llvm-project show -s

    PATH_OVERRIDE=${PWD}/bin "${TC_BLD}"/kernel/build.sh --allyesconfig
)}
# vi: filetype=zsh
