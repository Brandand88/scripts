# SPDX-License-Identifier: GPL-3.0-or-later
#
# Copyright (C) 2017-2020 Nathan Chancellor
#
# Utility and terminal setup functions


# Source our universal functions script
if [[ -n ${ZSH_NAME} ]]; then
    SCRIPT=${(%):-%x}
elif [[ -n ${BASH} ]]; then
    SCRIPT=${BASH_SOURCE[0]}
else
    echo "Unsupported shell!"
    return 1
fi
source "$(cd "$(dirname "$(readlink -f "${SCRIPT}")")" || return; pwd)/../common"
unset SCRIPT


# Source the machine specific functions
case "$(whoami)@$(uname -n)" in
    nathan@archlinux-*|nathan@ubuntu-*) LOCATION=workstation ;;
    nathan@Ryzen-7-3700X) LOCATION=wsl ;;
    *) LOCATION=generic ;;
esac
source "${SCRIPTS_FOLDER}/env/${LOCATION}"


# Universal aliases/functions
function aliases() {
    # hub alias
    command -v hub &>/dev/null && alias git='hub'

    # scripts folder alias
    alias spt='cd ${SCRIPTS_FOLDER}'

    # tmux alias
    command -v tmux &>/dev/null && alias tmux='tmux -u'

    source "${SCRIPTS_FOLDER}/env/stubs/bldupdbin"
    source "${SCRIPTS_FOLDER}/env/stubs/deldog"
    source "${SCRIPTS_FOLDER}/env/stubs/git"
    source "${SCRIPTS_FOLDER}/env/stubs/transfer"
}


# Try to attach via tmux
function tmxa() {
    command -v tmux &>/dev/null || return
    [[ -z ${TMUX} ]] && tmux new-session -AD -s main
}


# Smart tmux detach
# https://arslan.io/2019/01/07/using-the-ipad-pro-as-my-development-machine/
function tmxd() {
    local COUNT PANES WINS

    command -v tmux &>/dev/null || return
    [[ -z ${TMUX} ]] && builtin exit

    PANES=$(tmux list-panes | wc -l)
    WINS=$(tmux list-windows | wc -l)
    COUNT=$((PANES + WINS - 1))
    if [[ ${COUNT} -eq 1 ]]; then
        tmux detach
    else
        builtin exit
    fi
}


function shell_setup() {
    # Shell specific options
    if [[ -n ${ZSH_NAME} ]]; then
        [[ -n ${terminfo[khome]} ]] && bindkey "${terminfo[khome]}" beginning-of-line
        [[ -n ${terminfo[kend]} ]] && bindkey "${terminfo[kend]}" end-of-line

        setopt autocd
        typeset -gU path

        echo "$fpath" | grep -q -s "${HOME}/.zfunctions" || fpath=( "${HOME}/.zfunctions" $fpath )

        export HISTSIZE=100000
        export PURE_GIT_PULL=0
        export TIMEFMT=$'\nreal\t%*E\nuser\t%*U\nsys\t%*S'

        GIT_COMPLETIONS=${HOME}/usr/share/bash-completion/completions/git
        [[ -f ${GIT_COMPLETIONS} ]] && zstyle ':completion:*:*:git:*' script "${GIT_COMPLETIONS}"

        autoload -U compinit && compinit
        autoload -U promptinit && promptinit && prompt pure

        ZSH_HGHLGHT_SYNTAX=${HOME}/.zfunctions/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
        [[ -f ${ZSH_HGHLGHT_SYNTAX} ]] && source "${ZSH_HGHLGHT_SYNTAX}"
    elif [[ -n ${BASH} ]]; then
        shopt -s checkwinsize
    else
        echo "Unsupported shell!"
        return 1
    fi

    # Environment setup
    path_push "${HOME}/.cargo/bin"
    path_push "${HOME}/usr/bin"
    [[ -f ${HOME}/.del_dog_api_key ]] && source "${HOME}/.del_dog_api_key"
    [[ -f ${HOME}/.server_ip ]] && source "${HOME}/.server_ip"
    set_distro
    aliases
    "${LOCATION}"_aliases
    tmxa
    "${LOCATION}"_setup
    GPG_TTY=$(tty); export GPG_TTY
}


# {bash,zsh}rc reload function
function rld() {
    source "${SCRIPTS_FOLDER}/env/common"
    shell_setup
}


# Bind mount current PWD into Podman container
function podman_mount() {
    podman run --mount type=bind,source="${PWD}",target=/"${PWD##*/}",ro=true \
               --workdir /"${PWD##*/}" \
               "${@}"
}


# Get the current status of hardware vulnerabilities
function hwvulns() {
    grep --color=always . /sys/devices/system/cpu/vulnerabilities/*
}


# Update main server IP address file
function encrypt_serv_ip() {(
    [[ -f ${HOME}/.server_ip ]] || die "Server IP file could not be found"
    gpg --batch \
        --yes \
        --output ${SCRIPTS_FOLDER:?}/configs/common/server_ip.gpg \
        --encrypt \
        --recipient natechancellor@gmail.com \
        ${HOME}/.server_ip
)}


# Small macro for responding to a LKML post
function reply_to_lkml() {(
    MBOX=$(mktemp --suffix=.mbox) && \
    curl -LSso "${MBOX}" "${1:?}" && \
    mutt -f "${MBOX}"

    rm "${MBOX}"
)}


# Apply patch from LKML
function apply_from_lkml() {(
    LINK=${1:?} && \
    PATCH=$(mktemp --suffix=.patch) && \
    curl -LSso "${PATCH}" "${LINK//\/raw}"/raw
)}


# Generate a sha256sum file based on a URL
function gen_sha256sum() {(
    URL=${1:?}
    FILE=${1##*/}
    curl -LSsO "${1}"
    sha256sum "${FILE}" > "${FILE}".sha256
    rm -rf "${FILE}"
    curl -LSsO "${1}"
    sha256sum -c "${FILE}".sha256
    rm -rf "${FILE}"
)}


# Update my website
function upd_website() {(
    GITHUB=${HOME}/github
    WEBSITE=${GITHUB}/nathanchance.github.io
    HUGO_FILES=${GITHUB}/hugo-files

    [[ -d ${WEBSITE} && -d ${HUGO_FILES} ]] || die "Website and hugo-files should be cloned before running this function"

    while (( ${#} )); do
        case ${1} in
            -p|--push) PUSH=true ;;
        esac
        shift
    done

    cd "${HUGO_FILES}" || die "${HUGO_FILES} does not exist..."
    fd -E CNAME . "${WEBSITE}" -x rm -rf
    hugo -d "${WEBSITE}"

    HF_URL=$(git remote get-url origin | sed 's/git@github.com:/https:\/\/github.com\//')
    HF_HASH=$(git sh -s --format=%H)

    cd "${WEBSITE}"
    git aa
    git ac -m "website: Update to ${HF_URL}/commit/${HF_HASH}"
    ${PUSH:=false} || return 0
    git push
)}

# vi: filetype=zsh
