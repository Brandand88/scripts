#!/usr/bin/env bash
#
# Utility and terminal setup functions for Linux
#
# Copyright (C) 2017 Nathan Chancellor
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>


# Linux specific aliases
function linux_aliases() {
    # default Arch ls alias
    alias ls='ls --color=auto'

    # Update alias
    alias update='pacaur -Syyu'

    # Change directory aliases
    alias 6p='cd ${KERNEL_FOLDER}/flash/angler'
    alias asu='cd ${REPO_FOLDER}/asu'
    alias ayk='cd ${KERNEL_FOLDER}/flash/anykernel2'
    alias lnx='cd ${KERNEL_FOLDER}/sources/linux'
    alias pkg='cd ${REPO_FOLDER}/pkgbuilds'
    alias op5='cd ${KERNEL_FOLDER}/flash/op5'
    alias pxl='cd ${KERNEL_FOLDER}/flash/wahoo'
    alias tlc='cd ${TC_FOLDER}'
    alias spt='cd ${SCRIPTS_FOLDER}'

    # Generate a kernel version for the current tree
    alias kver='make kernelversion'

    # Setup build for AOSP
    alias senv='. build/envsetup.sh'

    # Alias for makepkg
    alias mkpkg='makepkg -si --noconfirm'
}

# Setup PS1 and such
function linux_prompt() {
    source ~/.git-prompt.sh
    export GIT_PS1_SHOWDIRTYSTATE=1
    export GIT_PS1_SHOWUPSTREAM=auto
    export PROMPT_COMMAND='__git_ps1 "\[\033[01;34m\]\u@\h \[\033[01;32m\]\w\[\033[01;31m\]" " \[\033[39m\]\$\[\033[0m\] "'
}

# Log support so I can see what compiled and at what time
function log_support() {
    export LOG_FOLDER=${WEB_FOLDER}/me/logs

    # Create LOG_FOLDER if it doesn't exist
    if [[ ! -d ${LOG_FOLDER} ]]; then
        mkdir -p ${LOG_FOLDER}/results
    fi
    
    export LOG=${LOG_FOLDER}/results/compile_log_$(date +%m_%d_%y).log
}

# Setup ccache
# ccache_setup <size>
function ccache_setup() {
    if [[ -n $(command -v ccache) ]]; then
        if [[ -n ${1} ]]; then
            ccache -M ${1}G &> /dev/null
            export USE_CCACHE=1
            add_to_path_pre "/usr/lib/ccache/bin"
        else
            display_error "Please specify ccache size!"
        fi
    else
        display_error "Please install ccache!"
    fi
}

# Additional setup steps for Linux
function linux_setup() {
    ccache_setup 150
    log_support
    add_to_path_post ${HOME}/.gem/ruby/2.4.0/bin
}

# Repo sync shorthand
function rps {
    local ARGS

    if [[ -n ${1} ]]; then
        case ${1} in
            "g")
                ARGS="vendor/google/build "
                ARGS+="vendor/opengapps/sources/all "
                ARGS+="vendor/opengapps/sources/arm "
                ARGS+="vendor/opengapps/sources/arm64" ;;
            *)
                ARGS="$@" ;;
        esac
    fi

    repo sync ${JOBS_FLAG} --force-sync -c --no-clone-bundle --no-tags --optimized-fetch --prune ${ARGS}
}

# Repo init and sync function
# ris <url> <branch> |-s|
function ris {
    # User requested a shallow clone
    if [[ ${3} = "-s" ]]; then
        local DEPTH="--depth=1"
    fi

    repo init -u ${1} -b ${2} --no-clone-bundle ${DEPTH}

    time repo sync ${JOBS_FLAG} --force-sync -c --no-clone-bundle --no-tags --optimized-fetch --prune
}

# Update Linux stable mirror
function upstb() {
    CUR_FOLDER=$(pwd)

    if [[ ! -d ${KERNEL_FOLDER}/mirrors/linux-stable ]]; then
        cd ${KERNEL_FOLDER}/mirrors
        git clone --mirror https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-stable
        cd linux-stable
        git remote set-url --push origin git@github.com:nathanchance/linux-stable
    fi

    if [[ ! -d ${KERNEL_FOLDER}/mirrors/linux-stable-rc ]]; then
        cd ${KERNEL_FOLDER}/mirrors
        git clone --mirror https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable-rc.git linux-stable-rc
    fi

    cd ${KERNEL_FOLDER}/mirrors/linux-stable

    git fetch -p origin
    git push --mirror

    cd ${KERNEL_FOLDER}/mirrors/linux-stable-rc

    git fetch -p origin

    cd ${CUR_FOLDER}
}

# Add kernel remotes to a kernel repo
function kremotes() {
    if [[ ! -f Makefile ]]; then
        display_error "Run this in a kernel tree!"
        return 1
    fi

    git remote add aosp-kc https://android.googlesource.com/kernel/common
    git remote add aosp-msm https://android.googlesource.com/kernel/msm
    git remote add chromium https://chromium.googlesource.com/chromiumos/third_party/kernel
    git remote add caf-4.4 https://source.codeaurora.org/quic/la/kernel/msm-4.4
    git remote add linux https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
    git remote add linux-stable https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git
    git remote add linux-stable-rc https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable-rc.git

    git remote update
}

# Merge one git tag into current branch
# mrgt <tag> [<remote|url>]
function merge-tag() {
    if [[ $# -gt 1 ]]; then
        git fetch --tags ${2}
    fi

    local MSG_FILE=/tmp/mrg-msg
    local CB=$(git rev-parse --abbrev-ref HEAD | sed 's/-queue-[0-9].*//')
    local TAG=${1}
    local RANGE=${CB}..${TAG}

    rm -rf ${MSG_FILE}
    echo "Merge ${TAG} into ${CB}" >> ${MSG_FILE}

    echo "\nCommits in ${TAG}: ($(git rev-list --count ${RANGE}) commits)" >> ${MSG_FILE}
    git log --reverse --format="        %s" ${RANGE} >> ${MSG_FILE}

    echo "\nSigned-off-by: $(git config --get user.name) <$(git config --get user.email)>" >> ${MSG_FILE}

    GIT_MERGE_VERBOSITY=1 git merge --gpg-sign --no-edit ${TAG}
    local MERGE_RESULT=$?

    CONFLICTS=$(git cf)
    if [[ -n ${CONFLICTS} ]]; then
        echo "\nConflicts:" >> ${MSG_FILE}
        for FILE in ${CONFLICTS}; do
            echo "\t${FILE}" >> ${MSG_FILE}
        done
    fi

    if [[ ${MERGE_RESULT} -ne 0 ]]; then
        display_error "Merge needs manual intervention!

Resolve conflicts then run git fm!"
        return 1
    else
        git commit --amend --no-edit --quiet --gpg-sign --file ${MSG_FILE}
        header "${TAG} merged cleanly!" ${GRN}
    fi
}

# Neofetch alias
function nf() {
    echo
    neofetch \
        --kernel_shorthand on \
        --distro_shorthand tiny \
        --os_arch off \
        --uptime_shorthand tiny \
        --speed_shorthand on \
        --install_time off \
        --color_blocks off
    echo
    echo
}

# Find config values in a kernel tree
# kfg [-c <defconfig_file>] [-f <config>] [-e <config>] [-d <config>]
function kfg() {
    local DEFCONFIG=flash_defconfig
    local CONFIG LIST

    while [[ $# -ge 1 ]]; do
        case ${1} in
            "-c"|"--config")
                shift

                DEFCONFIG=${1} ;;

            "-d"|"--disable")
                shift

                CONFIG=$(echo ${1} | sed s/CONFIG_//)

                echo "# CONFIG_${CONFIG} is not set" >> arch/arm64/configs/${DEFCONFIG} ;;

            "-e"|"--enable")
                shift

                CONFIG=$(echo ${1} | sed s/CONFIG_//)

                echo "CONFIG_${CONFIG}=y" >> arch/arm64/configs/${DEFCONFIG} ;;

            "-f"|"--find")
                shift

                CONFIG=$(echo ${1} | sed s/CONFIG_//)

                header "LOCATIONS OF ${CONFIG} IN TREE"
                git grep -n -1 ${CONFIG} | ag --nocolor Kconfig

                LIST=$(ag --nocolor ${CONFIG} out/.config)
                if [[ -n ${LIST} ]]; then
                    header "LOCATIONS OF ${CONFIG} IN CONFIG FILE"
                    echo "${LIST}"
                fi

                echo ;;

            "-u"|"--update")
                shift

                rm -rf out
                make O=out ARCH=arm64 ${DEFCONFIG}
                make O=out ARCH=arm64 savedefconfig
                cp -v out/defconfig arch/arm64/configs/${DEFCONFIG} ;;
        esac

        shift
    done
}

# Build a toolchain and release Flash Kernel builds
# frel <device> <version> [-nt]
function frel() {
    case ${1} in
        "op5")
            case ${2} in
                1.*)
                    flash-kernel -v ${2} -m stable -d op5 -os Custom -b 7.1.x-custom -av 7.1.x
                    flash-kernel -v ${2} -m stable -d op5 -os OOS -b 7.1.x-oos -av 7.1.x ;;
                2.*)
                    flash-kernel -v ${2} -m stable -d op5 -os Custom -b 8.0.0-custom -av 8.0.0
                    flash-kernel -v ${2} -m stable -d op5 -os OOS -b 8.0.0-oos -av 8.0.0 ;;
                3.*)
                    flash-kernel -v ${2} -m stable -d op5 -os Custom -b 8.x-unified -av 8.1.0
                    flash-kernel -v ${2} -m stable -d op5 -os OOS -b 8.x-unified -av 8.0.0 ;;
            esac ;;

        "pxl2")
            flash-kernel -v ${2} -m stable -d taimen -b oreo-mr1
            flash-kernel -v ${2} -m stable -d walleye -b oreo-mr1 ;;
    esac
}

# Build Flash Kernel test builds
# ftest <device> <version> <dirty_version> <type>
function ftest() {
    case ${1} in
        "op5")
            case ${2} in
                1.*)
                    flash-kernel -v ${2} -r ${3} -m ${4} -d op5 -os Custom -b queue-${2} -av 7.1.x
                    flash-kernel -v ${2} -r ${3} -m ${4} -d op5 -os OOS -b queue-${2} -av 7.1.x ;;
                2.*)
                    flash-kernel -v ${2} -r ${3} -m ${4} -d op5 -os Custom -b queue-${2} -av 8.0.0
                    flash-kernel -v ${2} -r ${3} -m ${4} -d op5 -os OOS -b queue-${2} -av 8.0.0 ;;
                3.*)
                    flash-kernel -v ${2} -r ${3} -m ${4} -d op5 -os Custom -b queue-${2} -av 8.1.0
                    flash-kernel -v ${2} -r ${3} -m ${4} -d op5 -os OOS -b queue-${2} -av 8.0.0 ;;
            esac ;;

        "pxl2")
            flash-kernel -v ${2} -r ${3} -m ${4} -d taimen -b queue-${2}
            flash-kernel -v ${2} -r ${3} -m ${4} -d walleye -b queue-${2} ;;
    esac
}

# Regenerate Pixel 2 build binaries
function rpb() {
    cd ${KERNEL_FOLDER}/sources/aosp-pixel2

    mkavenv
    . build/envsetup.sh
    lunch aosp_taimen-user
    make ${JOBS_FLAGS} clean
    make ${JOBS_FLAGS} dtc mkdtimg
    rmvenv

    cp out/host/linux-x86/bin/dtc ${BIN_FOLDER}
    cp out/host/linux-x86/bin/mkdtimg ${BIN_FOLDER}

    cd ${SCRIPTS_FOLDER}

    git status
}

# Reset test build folders function
function wfr() {
    case ${1} in
        "op5")
            rm -rf ${WEB_FOLDER}/downloads/kernels/op5/{7.1.x,8.0.0}/{custom,oos}/{alpha,beta,rc,tmp}/* ;;
        "pxl2")
            rm -rf ${WEB_FOLDER}/downloads/kernels/{taimen,walleye}/{8.0.0,8.1.0}/{alpha,beta,rc,tmp}/* ;;
    esac

    cd ${WEB_FOLDER}/downloads/kernels
}

# Generate git hashes with their subject line and links upstream (markdown commit format)
function mcf() {
    case ${1} in
        "c") URL="https://source.codeaurora.org/quic/la/kernel/msm-4.4/commit/?id=" ;;
        "g") URL="https://android.googlesource.com/kernel/msm/+/" ;;
        "l") URL="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/?id=" ;;
    esac

    echo
    echo "$(git show -s --format='%h ("%s")' ${2})"
    echo
    echo "ommit [\`$(git show -s --format=%h ${2})\`](${URL}$(git show -s --format='%H) ("%s")' ${2})"
    echo
}

# Sign zip files for TWRP flashability
function signzip() {
    local CUR_DIR=$(pwd)
    local FILE=${1}
    local KEY=testkey
    if [[ $(echo ${FILE} | grep -v zip) ]]; then
        display_error "This can only sign zip files!"
        return 1
    fi
    if [[ ! -f ${FILE} ]]; then
        display_error "Zip file does not exist!"
        return 1
    fi

    header "Signing ${FILE}"

    # Shift to the folder containing the zip
    cd $(dirname ${FILE})

    # Get the zip name
    ZIP_NAME=$(basename ${FILE} .zip)

    # Sign the zip
    java -jar ${BIN_FOLDER}/signapk.jar \
              ${BIN_FOLDER}/${KEY}.x509.pem \
              ${BIN_FOLDER}/${KEY}.pk8 \
              ${ZIP_NAME}.zip \
              ${ZIP_NAME}-firstsign.zip

    ${BIN_FOLDER}/zipadjust ${ZIP_NAME}-firstsign.zip \
                            ${ZIP_NAME}-adjusted.zip &>/dev/null

    java -jar ${BIN_FOLDER}/minsignapk.jar \
              ${BIN_FOLDER}/${KEY}.x509.pem \
              ${BIN_FOLDER}/${KEY}.pk8 \
              ${ZIP_NAME}-adjusted.zip \
              ${ZIP_NAME}-signed.zip
              
    # Remove intermediate zip files
    rm ${ZIP_NAME}-firstsign.zip ${ZIP_NAME}-adjusted.zip

    # Echo zip location
    echo "Signed zip: $(pwd)/${ZIP_NAME}-signed.zip\n"
    cd ${CUR_DIR}
}


# Manage queue tags
# queue-tag [-c|-d] <version>
function queue-tag() {
    if [[ ! -f Makefile ]]; then
        display_error "Run this in a kernel tree!"
        return 1
    fi

    case ${1} in
        "-c"|"--create")
            git tag -d queue-${2} 2>/dev/null
            git tag -a queue-${2} -m "Queue for Flash v${2}" -s
            git push -f origin queue-${2} ;;

        "-d"|"--delete")
            git tag -d queue-${2}
            git push origin :queue-${2} ;;
    esac
}
