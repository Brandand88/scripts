# SPDX-License-Identifier: GPL-3.0-or-later
#
# Copyright (C) 2019 Nathan Chancellor
#
# Functions to build the latest versions of certain pieces of software


# Build/update ccache
function bccache() {(
    [[ -z ${CCACHE_VERSION} ]] && CCACHE_VERSION=$(glr ccache/ccache)
    CCACHE_FOLDER=ccache-${CCACHE_VERSION//v}
    TMP_FOLDER=$(mktemp -d)
    cd "${TMP_FOLDER}"
    curl -LSs https://github.com/ccache/ccache/releases/download/"${CCACHE_VERSION}"/"${CCACHE_FOLDER}".tar.gz | tar -xzf -
    cd "${CCACHE_FOLDER}" || die "Downloading or extracting ccache failed"
    ./configure --prefix="${PREFIX:=${HOME}/usr}"
    make "${JOBS_FLAG:--j"$(nproc)"}" || die "make failed"
    make install || die "install failed"
    rm -rf "${TMP_FOLDER}"

    path_push "${PREFIX}"/bin
    command -v ccache
    ccache --version
)}


# Build/update git
function bgit() {(
    [[ -z ${PREFIX} ]] && PREFIX=${HOME}/usr
    [[ $(uname -m) =~ x86 ]] && MARCH="-march=native "
    MAKE=( make "${JOBS_FLAG:--j"$(nproc)"}"
                prefix="${PREFIX}"
                CFLAGS="${MARCH}-O2 -pipe -fstack-protector-strong -fno-plt"
                LDFLAGS="-Wl,-O1,--sort-common,--as-needed,-z,relro,-z,now"
                USE_LIBPCRE2=1
                NO_CROSS_DIRECTORY_HARDLINKS=1
                NO_PERL_CPAN_FALLBACKS=1 )

    GIT_FOLDER=${SRC_FOLDER:-${HOME}/src}/git
    if [[ ! -d ${GIT_FOLDER} ]]; then
        mkdir -p "${GIT_FOLDER%/*}"
        git clone git://github.com/git/git "${GIT_FOLDER}"
    fi
    cd "${GIT_FOLDER}" || die "Couldn't move into ${GIT_FOLDER}"

    git clean -fxdq
    git fetch

    [[ -z ${GIT_VERSION} ]] && GIT_VERSION=$(git describe --tags $(git rev-list --tags --max-count=1))
    git checkout v"${GIT_VERSION//v}"

    "${MAKE[@]}" all install || die "git build/install failed"

    if [[ -n ${ZSH_NAME} ]]; then
        mkdir -p "${PREFIX}"/share/bash-completion/completions/
        install -m 0644 "${GIT_FOLDER}"/contrib/completion/git-completion.bash "${PREFIX}"/share/bash-completion/completions/git

        [[ -d ${HOME}/.zfunctions ]] || mkdir -p "${HOME}/.zfunctions"
        install -m 0644 "${GIT_FOLDER}"/contrib/completion/git-completion.zsh "${HOME}"/.zfunctions/_git
    fi

    path_push "${PREFIX}"/bin
    command -v git
    git --version
)}


# Build/install PGO'd LLVM
function bpgollvm() {(
    CMAKE=( cmake -G Ninja
                  -Wno-dev
                  -DCLANG_DEFAULT_LINKER=lld
                  -DCLANG_VENDOR="$(uname -n)"
                  -DCMAKE_BUILD_TYPE=Release )
    FLAGS="-O3$([[ $(uname -m) = "x86_64" ]] && echo " -march=native -mtune=native")"
    LLVM_PROJECT=${SRC_FOLDER:-${HOME}/src}/llvm-project
    BUILD_FOLDER=${LLVM_PROJECT}/build
    START=$(date +%s)

    while (( ${#} )); do
        case ${1} in
            "-b"|"--branch") shift; LLVM_VERSION=${1} ;;
            "-t"|"--tip-of-tree") LLVM_VERSION=master ;;
        esac
        shift
    done
    [[ -z ${LLVM_VERSION} ]] && LLVM_VERSION=master

    header "Updating LLVM and cleaning up"
    [[ -d ${LLVM_PROJECT} ]] || { mkdir -p "${LLVM_PROJECT%/*}"; git clone https://github.com/llvm/llvm-project "${LLVM_PROJECT}"; }
    cd ${LLVM_PROJECT} || die "llvm-project clone failed"
    git reset --hard
    git clean -fxdq
    git fetch origin
    git checkout "${LLVM_VERSION}"
    # If we are on a branch, we should update it
    [[ ${LLVM_VERSION} = "master" || ${LLVM_VERSION} =~ release ]] && git pull

    # Ensure that we don't build llgo, it's broken
    LLVM_ALL_PROJECTS=$(grep -F "set(LLVM_ALL_PROJECTS " llvm/CMakeLists.txt | cut -d \" -f 2)
    CMAKE=( "${CMAKE[@]}" -DLLVM_ENABLE_PROJECTS="${LLVM_ALL_PROJECTS/;llgo}" )

    # Stage 1: Bootstrap compiler
    (
        header "Building LLVM stage 1"
        mkdir -p "${BUILD_FOLDER}"/stage1
        cd "${BUILD_FOLDER}"/stage1 || die "Error creating stage1 build folder"
        LINKER=$(if command -v ld.lld &>/dev/null; then echo lld; else echo gold; fi)
        "${CMAKE[@]}" -DCLANG_PLUGIN_SUPPORT=OFF \
                      -DCMAKE_C_COMPILER=clang \
                      -DCMAKE_C_FLAGS="${FLAGS}" \
                      -DCMAKE_CXX_COMPILER=clang++ \
                      -DCMAKE_CXX_FLAGS="${FLAGS}" \
                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF \
                      -DLLVM_ENABLE_BACKTRACES=OFF \
                      -DLLVM_INCLUDE_DOCS=OFF \
                      -DLLVM_INCLUDE_EXAMPLES=OFF \
                      -DLLVM_INCLUDE_TESTS=OFF \
                      -DLLVM_TARGETS_TO_BUILD=host \
                      -DLLVM_USE_LINKER=${LINKER} \
                      "${LLVM_PROJECT}"/llvm || die "Error configuring stage 1"
	ninja || die "Error building stage 1"
    ) || exit ${?}

    STAGE_ONE_BIN=${BUILD_FOLDER}/stage1/bin
    STAGE_ONE_BIN_DEFINES=( -DCMAKE_AR=${STAGE_ONE_BIN}/llvm-ar
                            -DCMAKE_C_COMPILER=${STAGE_ONE_BIN}/clang
                            -DCLANG_TABLEGEN=${STAGE_ONE_BIN}/clang-tblgen
                            -DCMAKE_CXX_COMPILER=${STAGE_ONE_BIN}/clang++
                            -DLLVM_USE_LINKER=${STAGE_ONE_BIN}/ld.lld
                            -DLLVM_TABLEGEN=${STAGE_ONE_BIN}/llvm-tblgen
                            -DCMAKE_RANLIB=${STAGE_ONE_BIN}/llvm-ranlib )

    # Stage 2a: Instrumented compiler
    (
        header "Building LLVM stage 2a"
        mkdir -p "${BUILD_FOLDER}"/stage2a
        cd "${BUILD_FOLDER}"/stage2a || die "Error creating stage2a build folder"
        export PATH=${STAGE_ONE_BIN:?}:${PATH}
        "${CMAKE[@]}" "${STAGE_ONE_BIN_DEFINES[@]}" \
                      -DCMAKE_C_FLAGS="${FLAGS}" \
                      -DCMAKE_CXX_FLAGS="${FLAGS}" \
                      -DLLVM_BUILD_INSTRUMENTED=IR \
                      -DLLVM_BUILD_RUNTIME=OFF \
                      -DLLVM_INCLUDE_GO_TESTS=OFF \
                      "${LLVM_PROJECT}"/llvm || die "Error configuring stage 2a"
        ninja clang lld check-clang check-llvm || die "Error building or checking stage2a"
    ) || exit ${?}

    STAGE_TWO_BIN=${BUILD_FOLDER}/stage2a/bin
    STAGE_TWO_BIN_DEFINES=( -DCMAKE_AR=${STAGE_TWO_BIN}/llvm-ar
                            -DCMAKE_C_COMPILER=${STAGE_TWO_BIN}/clang
                            -DCLANG_TABLEGEN=${STAGE_TWO_BIN}/clang-tblgen
                            -DCMAKE_CXX_COMPILER=${STAGE_TWO_BIN}/clang++
                            -DLLVM_USE_LINKER=${STAGE_TWO_BIN}/ld.lld
                            -DLLVM_TABLEGEN=${STAGE_TWO_BIN}/llvm-tblgen
                            -DCMAKE_RANLIB=${STAGE_TWO_BIN}/llvm-ranlib )

    # Stage 2b: Build clang with instrumented compiler
    (
        header "Building LLVM stage 2b"
        mkdir -p "${BUILD_FOLDER}"/stage2b
        cd "${BUILD_FOLDER}"/stage2b
        export PATH=${STAGE_TWO_BIN:?}:${PATH}
        "${CMAKE[@]}" "${STAGE_TWO_BIN_DEFINES[@]}" \
                      -DCMAKE_C_FLAGS="${FLAGS}" \
                      -DCMAKE_CXX_FLAGS="${FLAGS}" \
                      "${LLVM_PROJECT}"/llvm || die "Error configuring stage 2b"
        ninja || die "Error building stage 2b"
    ) || exit ${?}

    # Stage 3: Build final compiler
    (
        header "Building LLVM stage 3"
        mkdir -p "${BUILD_FOLDER}"/stage3
        cd "${BUILD_FOLDER}"/stage3 || die "Error creating stage 3 build folder"
        export PATH=${STAGE_ONE_BIN:?}:${PATH}

        # Merge profile data
        PROFILE_DATA=${BUILD_FOLDER}/stage3/profdata.prof
        llvm-profdata merge -output=${PROFILE_DATA} ${BUILD_FOLDER}/stage2a/profiles/*.profraw || die "Error merging profile data"

        # Build compiler with that data
        "${CMAKE[@]}" "${STAGE_ONE_BIN_DEFINES[@]}" \
                      -DCMAKE_C_FLAGS="${FLAGS} -Wno-backend-plugin" \
                      -DCMAKE_CXX_FLAGS="${FLAGS} -Wno-backend-plugin" \
                      -DCMAKE_INSTALL_PREFIX=${PREFIX:=${HOME}/usr} \
                      -DLLVM_ENABLE_LTO=Thin \
                      -DLLVM_PROFDATA_FILE=${PROFILE_DATA} \
                      "${LLVM_PROJECT}"/llvm || die "Error configuring stage 3"
        ninja || die "Error building stage 3"
        ninja install || die "Error installing stage 3"
    ) || exit ${?}

    header "Final LLVM information"

    TIME_STRING=$(format_time "${START}" "$(date +%s)")
    echo "Total build time: ${TIME_STRING:l}"

    path_push "${PREFIX}/bin"

    echo
    command -v clang
    clang --version | head -n1

    echo
    command -v ld.lld
    ld.lld --version
)}


# Build/install ripgrep
function birg() {(
    [[ -z ${RG_VERSION} ]] && RG_VERSION=$(glr BurntSushi/ripgrep)
    BASE_URL=https://github.com/BurntSushi/ripgrep
    TMP_FOLDER=$(mktemp -d)
    DEB=ripgrep_${RG_VERSION}_amd64.deb

    cd "${TMP_FOLDER}"

    if [[ $(uname -m) = "x86_64" ]] && command -v dpkg &>/dev/null; then
        curl -LSsO "${BASE_URL}"/releases/download/"${RG_VERSION}"/"${DEB}" || die "Error downloading ${DEB}"
        sudo_wrapper dpkg -i "${DEB}" || die "Error installing ${DEB}"
    else
        curl -LSs "${BASE_URL}"/archive/"${RG_VERSION}".tar.gz | tar -xzf - || die "Error downloading ripgrep source"
        cd ripgrep-"${RG_VERSION}" || die "Can't move into ripgrep source"
        [[ -d ${HOME}/.cargo/bin ]] || install_rust
        path_push "${HOME}/.cargo/bin"
        cargo build --release --locked --features 'pcre2' || die "cargo build failed"
        cargo install --force --path . || die "cargo install failed"
        if [[ -n ${ZSH_NAME} ]]; then
            [[ -d ${HOME}/.zfunctions ]] || mkdir -p "${HOME}/.zfunctions"
            install -Dm644 complete/_rg ${HOME}/.zfunctions/_rg
        fi
    fi

    command -v rg
    rg --version

    rm -rf "${TMP_FOLDER}"
)}


# Build/install sharkdp binaries
function bisharkdp() {(
    BINARIES=()
    while (( ${#} )); do
        case ${1} in
            all) BINARIES=( bat diskus fd hyperfine ) ;;
            bat|diskus|fd|hyperfine) BINARIES+=( "${1}" ) ;;
            *) die "Unsupported binary detected" ;;
        esac
        shift
    done

    TMP_FOLDER=$(mktemp -d)
    cd "${TMP_FOLDER}"

    for BINARY in "${BINARIES[@]}"; do (
        URL_BASE=https://github.com/sharkdp/"${BINARY}"
        [[ -z ${VERSION} ]] && VERSION=$(glr sharkdp/"${BINARY}")
        if [[ $(uname -m) = "x86_64" ]] && command -v dpkg &>/dev/null; then
            DEB=${BINARY}_${VERSION//v}_amd64.deb
            curl -LSsO "${URL_BASE}"/releases/download/"${VERSION}"/"${DEB}" || die "Error downloading ${DEB}"
            sudo_wrapper dpkg -i "${DEB}" || die "Error installing ${DEB}"
        else
            curl -LSs "${URL_BASE}"/archive/"${VERSION}".tar.gz | tar -xzf - || die "Error downloading ${BINARY} source"
            cd "${BINARY}-${VERSION}" || die "Can't move into ${BINARY} source"
            [[ -d ${HOME}/.cargo/bin ]] || install_rust
            path_push "${HOME}/.cargo/bin"
            cargo build --release --locked || die "cargo build failed"
            cargo install --force --path . || die "cargo install failed"
            if [[ -n ${ZSH_NAME} ]]; then
                [[ -d ${HOME}/.zfunctions ]] || mkdir -p "${HOME}/.zfunctions"
                case ${BINARY} in
                    fd) install -Dm644 target/release/build/fd-find-*/out/_fd ${HOME}/.zfunctions/_fd ;;
                esac
            fi
        fi

        command -v "${BINARY}"
        "${BINARY}" --version
    ); done

    rm -rf "${TMP_FOLDER}"
)}


# Build/install QEMU
function bqemu() {(
    [[ -z ${PREFIX} ]] && PREFIX=${HOME}/usr
    QEMU_FOLDER=${SRC_FOLDER:-${HOME}/src}/qemu
    if [[ ! -d ${QEMU_FOLDER} ]]; then
        mkdir -p "${QEMU_FOLDER%/*}"
        git clone --recursive -j$(nproc) https://git.qemu.org/git/qemu.git "${QEMU_FOLDER}"
    fi
    cd "${QEMU_FOLDER}" || die "Couldn't move into ${QEMU_FOLDER}"
    [[ -z ${QEMU_VERSION} ]] && QEMU_VERSION=$(git describe --abbrev=0)
    git cl -q
    git submodule foreach --recursive git cl -q
    git rh
    git submodule foreach --recursive git rh
    git submodule deinit slirp 2>/dev/null
    git checkout v"${QEMU_VERSION//v}"
    ( git merge-base --is-ancestor fc1120a7f5f2d4b601003205c598077d3eb11ad2 HEAD && \
      ! git merge-base --is-ancestor ece628fcf69cbbd4b3efb6fbd203af07609467a2 HEAD ) && \
    git cherry-pick ece628fcf69cbbd

    ./configure \
        --disable-bluez \
        --disable-docs \
        --disable-gcrypt \
        --disable-gnutls \
        --disable-gtk \
        --disable-libssh \
        --disable-nettle \
        --disable-opengl \
        --disable-sdl \
        --disable-strip \
        --disable-user \
        --disable-virglrenderer \
        --disable-vnc-png \
        --disable-vte \
        --disable-xen \
        --disable-xen-pci-passthrough \
        --extra-cflags=-g \
        --prefix=${PREFIX}

    make -j$(nproc) install

    path_push "${PREFIX}"/bin
    for QEMU_SUFFIX in aarch64 arm mipsel ppc ppc64 x86_64; do
        command -v qemu-system-${QEMU_SUFFIX}
        qemu-system-${QEMU_SUFFIX} --version
    done
)}


# Build/update tmux
function btmux() {(
    [[ -z ${TMUX_VERSION} ]] && TMUX_VERSION=$(glr tmux/tmux)
    TMP_FOLDER=$(mktemp -d)
    TMUX_FOLDER=tmux-${TMUX_VERSION}

    cd "${TMP_FOLDER}"
    curl -LSs https://github.com/tmux/tmux/releases/download/"${TMUX_VERSION}"/"${TMUX_FOLDER}".tar.gz | tar -xzf -
    cd "${TMUX_FOLDER}" || die "Downloading or extracting tmux failed"
    ./configure --prefix="${PREFIX:=${HOME}/usr}"
    make "${JOBS_FLAG:--j"$(nproc)"}" || die "make failed"
    make install || die "install failed"
    rm -rf "${TMP_FOLDER}"

    path_push "${PREFIX}"/bin
    command -v tmux
    tmux -V
)}


# Build/update zsh
function bzsh() {(
    ZSH_VERSION=latest
    [[ ${#} -gt 0 ]] && ZSH_VERSION=${1}
    TMP_FOLDER=$(mktemp -d)

    cd "${TMP_FOLDER}"
    case ${ZSH_VERSION} in
        latest) URL=https://sourceforge.net/projects/zsh/files/latest/download ;;
        *) URL=https://www.zsh.org/pub/"${ZSH_FOLDER}".tar.xz ;;
    esac
    curl -LSs "${URL}" | tar -xJf -
    cd zsh-* || die "Downloading or extracting zsh failed"
    ./configure --prefix="${PREFIX:=${HOME}/usr}"
    make "${JOBS_FLAG:--j"$(nproc)"}" || die "make failed"
    make install || die "install failed"
    rm -rf "${TMP_FOLDER}"

    ZSH_BIN=${PREFIX:?}/bin/zsh
    echo "${ZSH_BIN}" | sudo_wrapper tee -a /etc/shells
    sudo_wrapper chsh -s "${ZSH_BIN}" "$(whoami)"

    path_push "${PREFIX}"/bin
    command -v zsh
    zsh --version
)}


function install_rust() {(
    curl https://sh.rustup.rs -sSf | bash -s -- -y --no-modify-path
)}


function bldupdbin() {(
    bccache || exit ${?}
    bgit || exit ${?}
    bqemu || exit ${?}
    birg || exit ${?}
    bisharkdp all || exit ${?}
    btmux || exit ${?}
    bzsh || exit ${?}
)}
# vi: filetype=zsh
