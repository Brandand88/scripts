# SPDX-License-Identifier: GPL-3.0-or-later
#
# Copyright (C) 2018-2019 Nathan Chancellor
#
# Functions used to assist with ClangBuiltLinux development


# Universal variables
CBL_SRC=${CBL}/src
CBL_USR=${CBL}/usr
CBL_BIN=${CBL_USR}/bin
TCBLD=${CBL}/tc-build


# Create build folders
function crbf() {
    local ITEM
    for ITEM in binutils kernel llvm; do
        export "$(echo ${ITEM:0:1} | tr '[:lower:]' '[:upper:]')BF=${BLDF}/${ITEM}"
        mkdir -p "${BLDF}/${ITEM}"
    done
}


# Patch check function
function pch() {
    [[ -f scripts/checkpatch.pl ]] && git fp -1 --stdout "${@}" | ./scripts/checkpatch.pl
    [[ -f scripts/get_maintainer.pl ]] && git fp -1 --stdout "${@}" | ./scripts/get_maintainer.pl
}


# Quilt-like patch management function for Linux
function ptchmn() {(
    [[ ! -f Makefile ]] && { display_error "You're not in a kernel folder!"; return 1; }

    TARGET_FOLDER=${REPO_FOLDER}/patches/linux/$(git cb)
    [[ ! -d ${TARGET_FOLDER} ]] && { display_error "${TARGET_FOLDER} doesn't exist!"; return 1; }

    case "${1:?}" in
        "-s"|"--sync")
            FIRST_HASH=$(git log --reverse --format=%H --committer="$(git config --get user.name) <$(git config --get user.email)>" origin/stable..HEAD | head -n1)

            rm "${TARGET_FOLDER}"/*

            git fp -o "${TARGET_FOLDER}" "${FIRST_HASH}"^..HEAD

            git -C "${TARGET_FOLDER}" aa

            git -C "${TARGET_FOLDER}" c -m "patches: linux: $(git cb): Sync as of $(git sh -s --format=%h)"

            git -C "${TARGET_FOLDER}" push ;;

        "-a"|"--apply")
            git am "${TARGET_FOLDER}"/* ;;
    esac
)}


# Rebase a linux-next branch
function rbln() {(
    [[ ! -f Makefile ]] && { display_error "You're not in a kernel folder!"; return 1; }
    FIRST_HASH=$(git log --reverse --format=%H --committer="$(git config --get user.name) <$(git config --get user.email)>" origin/stable..HEAD | head -n1)
    SECOND_HASH=$(git show -s --format=%H "$(git cb)")
    git rh origin/master
    git cherry-pick --gpg-sign "${FIRST_HASH}^..${SECOND_HASH}"
)}


# Download and apply an LLVM/Clang/lld patch
function phabap() {(
    [[ ! -d llvm ]] && { display_error "You're not in the llvm-project folder!"; return 1; }

    REVISION=${1:?}
    [[ ${#} -ge 1 ]] && shift

    curl -LSs "https://reviews.llvm.org/${REVISION}?download=true" | git ap "${@}" || return 1
    git ac -m "${REVISION}

Link: https://reviews.llvm.org/${REVISION}"
)}


# Build kernel with Clang (wrapper)
function bldkw() {(
    if [[ ! -f Makefile ]]; then
        display_error "No Makefile found! Are you in a kernel tree?"
        return
    fi

    TARGET_ARCH=${1}; shift
    case "${TARGET_ARCH}" in
        "arm") MAKE_FLAGS=( "ARCH=arm" "CROSS_COMPILE=arm-linux-gnueabi-" ) ;;
        "arm64") MAKE_FLAGS=( "ARCH=arm64" "CROSS_COMPILE=aarch64-linux-gnu-" ) ;;
        "ppc64le") MAKE_FLAGS=( "ARCH=powerpc" "CROSS_COMPILE=powerpc64le-linux-gnu-" ) ;;
        "x86") MAKE_FLAGS=() ;;
        *) display_error "Invalid TARGET_ARCH specified!"; return ;;
    esac

    # We are only concerned about little endian for ARM right now unless otherwise stated
    if [[ ${TARGET_ARCH} =~ arm && -z ${BIG_ENDIAN} ]]; then
        KCONFIG_ALLCONFIG=${KBF}/little-endian.config
        echo "CONFIG_CPU_BIG_ENDIAN=n" >> "${KCONFIG_ALLCONFIG}"
    fi

    # Use our versions of Clang
    move_to_front_of_path "${CBL_BIN}"
    [[ -n ${PATH_OVERRIDE} ]] && move_to_front_of_path "${PATH_OVERRIDE}"

    # Build the kernel
    time make ${QUIET:+-s} \
              "${JOBS_FLAG}" \
              AR=llvm-ar \
              CC="${CCACHE} clang" \
              ${KCONFIG_ALLCONFIG:+KCONFIG_ALLCONFIG="${KCONFIG_ALLCONFIG}"} \
              HOSTCC="${CCACHE} clang" \
              HOSTCXX="${CCACHE} clang++" \
              HOSTLD=ld.lld \
              HOSTLDFLAGS="-fuse-ld=lld" \
              "${MAKE_FLAGS[@]}" \
              NM=llvm-nm \
              O="${KBF}" \
              OBJDUMP=llvm-objdump \
              STRIP=llvm-strip \
              "${@}"
)}


# Extra configs for build/boot testings
# From https://github.com/groeck/linux-build-test/blob/master/rootfs/scripts/common.sh
function extraconfigs() {
    local OUT_FOLDER="${KBF}"

    echo "CONFIG_INIT_STACK_ALL=y
CONFIG_EXPERT=y
CONFIG_DEBUG_KERNEL=y
CONFIG_LOCK_DEBUGGING_SUPPORT=y
CONFIG_DEBUG_RT_MUTEXES=y
CONFIG_DEBUG_SPINLOCK=y
CONFIG_DEBUG_MUTEXES=y
CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y
CONFIG_DEBUG_LOCK_ALLOC=y
CONFIG_DEBUG_LOCKDEP=y
CONFIG_DEBUG_ATOMIC_SLEEP=y
CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
CONFIG_CRC32_SELFTEST=y
CONFIG_DEBUG_LOCKING_API_SELFTESTS=y
CONFIG_DEBUG_NMI_SELFTEST=y
CONFIG_DEBUG_RODATA_TEST=y
CONFIG_DEBUG_TLBFLUSH=y
CONFIG_DMATEST=y
CONFIG_GLOB_SELFTEST=y
CONFIG_PCI_EPF_TEST=y
CONFIG_PCI_ENDPOINT_TEST=y
CONFIG_PROVE_LOCKING=y
CONFIG_PROVE_RCU=y
CONFIG_RBTREE_TEST=y
CONFIG_RCU_EQS_DEBUG=y
CONFIG_STATIC_KEYS_SELFTEST=y
CONFIG_STRING_SELFTEST=y
CONFIG_TEST_BITMAP=y
CONFIG_TEST_FIRMWARE=y
CONFIG_TEST_SORT=y
CONFIG_TEST_SYSCTL=y
CONFIG_TEST_UUID=y
CONFIG_TORTURE_TEST=y
CONFIG_USB_TEST=y
CONFIG_USB_EHSET_TEST_FIXTURE=y
CONFIG_USB_LINK_LAYER_TEST=y
CONFIG_WW_MUTEX_SELFTEST=y
CONFIG_BLK_DEV_INITRD=y
CONFIG_DEVTMPFS=y
CONFIG_DEVTMPFS_MOUNT=y
CONFIG_SCSI=y
CONFIG_BLK_DEV_SD=y
CONFIG_SCSI_LOWLEVEL=y
CONFIG_SCSI_DC395x=y
CONFIG_SCSI_AM53C974=y
CONFIG_SCSI_SYM53C8XX_2=y
CONFIG_MEGARAID_SAS=y
CONFIG_FUSION=y
CONFIG_FUSION_SAS=y
CONFIG_MMC=y
CONFIG_MMC_SDHCI=y
CONFIG_MMC_SDHCI_PCI=y
CONFIG_BLK_DEV_NVME=y
CONFIG_USB=y
CONFIG_USB_XHCI_HCD=y
CONFIG_USB_EHCI_HCD=y
CONFIG_USB_OHCI_HCD=y
CONFIG_USB_STORAGE=y
CONFIG_USB_UAS=y
CONFIG_VIRTIO=y
CONFIG_VIRTIO_PCI=y
CONFIG_VIRTIO_PCI_LEGACY=y
CONFIG_VIRTIO_BALLOON=y
CONFIG_VIRTIO_MMIO=y
CONFIG_BLK_MQ_VIRTIO=y
CONFIG_VIRTIO_BLK=y
CONFIG_VIRTIO_BLK_SCSI=y
CONFIG_SCSI_VIRTIO=y" >> "${OUT_FOLDER}"/.config

    [[ ${ARCH} =~ arm ]] && echo "CONFIG_LOCK_TORTURE_TEST=y
CONFIG_RCU_TORTURE_TEST=y" >> "${OUT_FOLDER}"/.config

    bldkw "${ARCH}" olddefconfig &>/dev/null
}


# Configure and build a kernel with Clang
function bldk() {
    # Parameters
    local ARCH CONFIG LD
    ARCH=${1}; shift
    CONFIG=${1}; shift

    # Sanity checks
    [[ -z ${ARCH} ]] && { display_error "ARCH not specified!"; return 1; }
    [[ -z ${CONFIG} ]] && { display_error "CONFIG not specified!"; return 1; }
    case ${ARCH} in
        "arm"|"arm64"|"x86"|"ppc64le") ;;
        *) display_error "Invalid ARCH specifed"; return 1 ;;
    esac

    # Clean up
    cbf k

    # Configure kernel
    bldkw "${ARCH}" "${CONFIG}" modules_prepare
    if [[ ${PWD} =~ cbl && ${CONFIG} =~ defconfig ]]; then
        extraconfigs
        # Use lld by default for everything but powerpc
        [[ -z ${LD} && ! ${ARCH} =~ ppc ]] && LD=ld.lld
        # Use llvm-objcopy
        [[ -z ${OBJCOPY} ]] && OBJCOPY=llvm-objcopy

    fi

    # Build kernel
    bldkw "${ARCH}" ${LD:+LD="${LD}"} "${@}" || return 1
}


# Configure and build a folder in the kernel with Clang
function bldkf() {
    # Parameters
    local ARCH CONFIG FOLDER
    ARCH=${1}; shift
    CONFIG=${1}; shift
    FOLDER=${1}; shift

    [[ -z ${FOLDER} ]] && { display_error "FOLDER not specified!"; return 1; }
    [[ ! -d ${FOLDER} ]] && { display_error "${FOLDER} could not be found!"; return 1; }

    bldk "${ARCH}" "${CONFIG}" M="${KBF}" src="${FOLDER}" "${@}"
}


# Boot a kernel in QEMU
function bootk() {
    local ARCH COMMAND IMAGES_FOLDER KERNEL RAM QEMU; ARCH=${1}; shift
    [[ -z ${ARCH} ]] && { display_error "ARCH not specified!"; return 1; }

    IMAGES_FOLDER=${CBL}/git/ci-master/images
    [[ ! -d ${IMAGES_FOLDER} ]] && { display_error "${IMAGES_FOLDER} doesn't exist!"; return 1; }

    case ${ARCH} in
        "arm")
            IMAGE=zImage
            QEMU=qemu-system-arm
            QEMU_ARCH_CMDLINE=( -machine virt
                                -no-reboot
                                -drive "file=${IMAGES_FOLDER}/arm/rootfs.ext4,format=raw,id=rootfs,if=none"
                                -device "virtio-blk-device,drive=rootfs"
                                -append "console=ttyAMA0 root=/dev/vda ${QEMU_CMDLINE}" ) ;;
        "arm64")
            IMAGE=Image.gz
            QEMU=qemu-system-aarch64
            QEMU_ARCH_CMDLINE=( -cpu cortex-a57
                                -drive "file=${IMAGES_FOLDER}/arm64/rootfs.ext4,format=raw"
                                -append "console=ttyAMA0 root=/dev/vda ${QEMU_CMDLINE}" ) ;;
        "ppc64le")
            IMAGE=zImage.epapr
            RAM=2G
            QEMU=qemu-system-ppc64
            QEMU_ARCH_CMDLINE=( -machine powernv
                                -device "ipmi-bmc-sim,id=bmc0"
                                -device "isa-ipmi-bt,bmc=bmc0,irq=10"
                                -L /usr/share/qemu -bios skiboot.lid
                                -initrd "${IMAGES_FOLDER}/ppc64le/rootfs.cpio"
                                ${QEMU_CMDLINE:+-append "${QEMU_CMDLINE}"} )
            ARCH=powerpc ;;
        "x86")
            IMAGE=bzImage
            QEMU=qemu-system-x86_64
            QEMU_ARCH_CMDLINE=( -append "root=/dev/sda console=ttyS0 ${QEMU_CMDLINE}"
                                -cpu host
                                -d unimp,guest_errors
                                -drive "file=${IMAGES_FOLDER}/x86_64/rootfs.ext4,format=raw,if=ide"
                                -enable-kvm ) ;;
        *) display_error "Invalid ARCH specified!"; return 1 ;;
    esac

    KERNEL=${KERNEL_LOCATION:-${KBF}}/arch/${ARCH}/boot/${IMAGE}
    [[ ! -f ${KERNEL} ]] && { display_error "Kernel doesn't exist! Please build one."; return 1; }

    # Update the images
    git -C "${IMAGES_FOLDER}" rh --quiet
    git -C "${IMAGES_FOLDER}" pull --quiet

    # Print or run the command
    COMMAND=( "${QEMU}" "${QEMU_ARCH_CMDLINE[@]}" -kernel "${KERNEL}" -m "${RAM:-512m}" -nographic )
    [[ -z ${NO_TIMEOUT} ]] && COMMAND=( timeout 2m unbuffer "${COMMAND[@]}" )
    [[ ${1} = "--print" ]] && { echo "${COMMAND[*]}"; return; }

    case ${ARCH} in
        "arm64")
            "${COMMAND[@]}" -machine virt "${@}"
            "${COMMAND[@]}" -machine "virt,virtualization" "${@}" ;;
        *)
            "${COMMAND[@]}" "${@}" ;;
    esac

}


# Build a kernel and boot it
function babk() {
    local ARCH DEFCONFIG LD
    ARCH=${1}; shift
    [[ -z ${ARCH} ]] && { display_error "ARCH not specified!"; return 1; }

    # Use lld by default for everything but powerpc
    [[ -z ${LD} && ! ${ARCH} =~ ppc ]] && LD=ld.lld

    # Use llvm-objcopy
    [[ -z ${OBJCOPY} ]] && OBJCOPY=llvm-objcopy

    # Define a different defconfig for ppc64le
    [[ ${ARCH} = "ppc64le" ]] && DEFCONFIG=powernv_defconfig

    bldk "${ARCH}" "${DEFCONFIG:-defconfig}" KCFLAGS="-Werror" ${LD:+LD="${LD}"} ${OBJCOPY:+OBJCOPY="${OBJCOPY}"} "${@}"

    bootk "${ARCH}"
}


# linux testing
function lt() {(
    cd "${CBL}"/"${TREE:=linux-next}" || die "wtf"

    while (( ${#} )); do
        case ${1} in
            "-d"|"--debug") DEBUG=true ;;
            # Show non-fatal warnings
            "-w"|"--warnings") SHOW_NF_WARNINGS=true ;;
        esac
        shift
    done

    # Logging
    LOG=$(mktemp)
    echo
    echo "Build log: ${LOG}"
    echo
    {
        (
            path_push "${CBL_BIN}"
            [[ -n ${PATH_OVERRIDE} ]] && path_push "${PATH_OVERRIDE}"
            echo "clang location: $(command -v clang)"
            echo
            clang --version | head -n1
        )
        echo
        echo "Version: $(make defconfig &>/dev/null && make kernelrelease | tail -n1 && git cl -q)"
        echo
        if [[ ${TREE} != linux-next ]]; then
            echo "Head commit: $(git kf origin/"$(git cb)")"
            echo
        fi
    } > "${LOG}"

    # Configurations known to build with -Werror
    CONFIGS=( "arm:multi_v7_defconfig"
              "arm:allyesconfig"
              "arm64:defconfig"
              "arm64:allyesconfig"
              "ppc64le:powernv_defconfig"
              "x86:defconfig"
              "x86:allyesconfig" )

    for CONFIG in "${CONFIGS[@]}"; do (
        ARCH=${CONFIG%%:*}
        CONFIG=${CONFIG##*:}

        START=$(date +%s)

        # Error log
        ERRORS=$(mktemp)

        # Use lld by default for everything but powerpc
        [[ -z ${LD} && ! ${ARCH} =~ ppc ]] && LD=ld.lld

        # Use llvm-objcopy
        [[ -z ${OBJCOPY} ]] && OBJCOPY=llvm-objcopy

        # Build kernel silently normally
        if [[ -z ${DEBUG} ]]; then
            bldk "${ARCH}" "${CONFIG}" KCFLAGS="${KCFLAGS:--Werror}" ${LD:+LD="${LD}"} ${OBJCOPY:+OBJCOPY="${OBJCOPY}"} |& \
            rg --color=never "error:|warning:|undefined" |& sed "s/${PWD//\//\\/}\///g" > "${ERRORS}"
            MAKE_RESULT=${pipestatus[1]}
        else
            bldk "${ARCH}" "${CONFIG}" KCFLAGS="${KCFLAGS:--Werror}" ${LD:+LD="${LD}"}
            MAKE_RESULT=${?}
        fi

        # Make sure that if make fails, it gets propgated to the if statement
        if [[ ${MAKE_RESULT} -eq 0 ]]; then
            RESULT=successful
        else
            RESULT=failed
        fi
        TIME_STRING=$(format_time "${START}" "$(date +%s)")
        {
            echo "${ARCH}:${CONFIG} | Build ${RESULT} in ${TIME_STRING:l}\c"
            if [[ ${RESULT} = "successful" && ${CONFIG} =~ defconfig ]]; then
                if bootk "${ARCH}" &>/dev/null; then
                    echo " | Boot successful\c"
                else
                    echo " | Boot failed\c"
                fi
            fi
            echo
            [[ -z ${DEBUG} && ( -n ${SHOW_NF_WARNINGS} || ${RESULT} = "failed" ) ]] && cat "${ERRORS}"
            echo
        } >> "${LOG}"
        rm "${ERRORS}"
    ) done

    MESSAGE="linux$([[ -f localversion-next ]] && cat localversion-next) build results: $(deldog "${LOG}")"

    tg_msg "${MESSAGE}"

    echo
    echo "${MESSAGE}"
    echo

    rm "${LOG}"
)}


# Pull the latest CBL Docker image and run it
function dckrrn() {(
    [[ -z ${DOCKER_IMAGE} ]] && DOCKER_IMAGE=clangbuiltlinux/debian
    [[ -z ${LOCAL} ]] && docker pull "${DOCKER_IMAGE}"
    docker_mount --interactive \
                 --rm \
                 --tty \
                 "${DOCKER_IMAGE}" "${@}"
)}


# Strip LLVM binaries
function stripllvmbin() {(
    BINARIES_TO_STRIP=( clang lld llvm-ar llvm-pdbutil llvm-symbolizer llvm-undname sancov )
    for BINARY in "${BINARIES_TO_STRIP[@]}"; do strip "${1:?}"/bin/"${BINARY}"; done
)}


# Build LLVM
function bldllvm() {(
    "${TCBLD}"/build-llvm.py "${@}"
)}


# Build binutils
function bldbn() {(
   "${TCBLD}"/build-binutils.py "${@}"
)}


# Build LLVM/Clang/lld and arm{32,64} and powerpc binutils from source
function bldusr() {(
    : ${INSTALL_FOLDER:=${CBL_USR}}
    rm -rf "${INSTALL_FOLDER}"

    # Build LLVM/Clang/lld
    bldllvm --build-folder "${LBF}" --install-folder "${INSTALL_FOLDER}" --thin-lto --update || return ${?}
    stripllvmbin "${INSTALL_FOLDER}"

    # Build binutils
    bldbn -B "${BBF}" -I "${INSTALL_FOLDER}"
)}


# kernel/common build wrapper
function kcbw() {(
    BUILD_FOLDER=${CBL}/android/build
    COMMON_FOLDER=${CBL}/android/common
    OUT_FOLDER=${BLDF}/common

    while (( ${#} )); do
        case ${1} in
            CC=*|LD=*) export "${1:?}" ;;
            3.*|4.*) BRANCH=${1} ;;
        esac
        shift
    done

    BRANCH=android-${BRANCH:-4.9}
    [[ -z ${LD} && ${BRANCH} = "android-4.19" ]] && LD=ld.lld

    cd "${BUILD_FOLDER}" || die "wtf"

    echo 'ARCH=arm64
BRANCH='"${BRANCH}"'
CLANG_TRIPLE=aarch64-linux-gnu-
CROSS_COMPILE='"${CROSS_COMPILE:-"aarch64-linux-gnu-"}"'
DEFCONFIG=cuttlefish_defconfig
EXTRA_CMDS='\'''\''
KERNEL_DIR='"$(realpath --relative-to="${PWD}" "${COMMON_FOLDER}")"'
POST_DEFCONFIG_CMDS="check_defconfig && update_clang_config"
CLANG_PREBUILT_BIN='"$(realpath --relative-to="${PWD}" "${CPB:-${CBL_BIN}}")"'
LD_LIBRARY_PATH='"${LD_LIBRARY_PATH:-"${CBL_USR}"/lib}"'
LINUX_GCC_CROSS_COMPILE_PREBUILTS_BIN='"$(realpath --relative-to="${PWD}" "${GCCPB:-${CBL_BIN}}")"'
FILES="
arch/arm64/boot/Image.gz
vmlinux
System.map
"
STOP_SHIP_TRACEPRINTK=1

function update_clang_config() {
  ${KERNEL_DIR}/scripts/config --file ${OUT_DIR}/.config \
    -e LTO_CLANG \
    -e CFI_CLANG \
    --set-val FRAME_WARN 2048
  (cd ${KERNEL_DIR} && \
    make O=${OUT_DIR} ${CC_LD_ARG} olddefconfig)
}' > "${BUILD_CONFIG:=$(mktemp)}"

    # Make path relative
    BUILD_CONFIG=$(realpath --relative-to="${PWD}" "${BUILD_CONFIG}")

    # Make sure that we are on the correct branch
    (
        cd "${COMMON_FOLDER}" || return
        git ch "${BRANCH}" || { git rh -q && git ch "${BRANCH}"; }
        git pull --rebase
    )

    OUT_DIR=${OUT_FOLDER} BUILD_CONFIG=${BUILD_CONFIG} CC="${CC:-clang}" LD="${LD}" ./build.sh "${@}"
)}


# kernel/common build testing
function kct() {(
    COMMON_FOLDER=${CBL}/android/common
    OUT_FOLDER=${BLDF}/common

    while (( ${#} )); do
        case ${1} in
            "-d"|"--debug") DEBUG=true ;;
            # Show non-fatal warnings
            "-w"|"--warnings") SHOW_NF_WARNINGS=true ;;
        esac
        shift
    done

    # Logging
    LOG=$(mktemp)
    echo
    echo "Build log: ${LOG}"
    echo
    {
        "${CBL_BIN}"/clang --version | head -n1
        echo
    } > "${LOG}"

    for VERSION in 4.9 4.14 4.19; do (
        START=$(date +%s)

        # Error log
        ERRORS=$(mktemp)

        # Build kernel silently normally
        if [[ -z ${DEBUG} ]]; then
            kcbw "${VERSION}" KCFLAGS="${KCFLAGS:--Werror}" |& \
            rg --color=never "error:|warning:|undefined" |& sed "s/${COMMON_FOLDER//\//\\/}\///g" > "${ERRORS}"
            MAKE_RESULT=${pipestatus[1]}
        else
            kcbw "${VERSION}" KCFLAGS="${KCFLAGS:--Werror}"
            MAKE_RESULT=${?}
        fi

        # Make sure that if make fails, it gets propgated to the if statement
        if [[ ${MAKE_RESULT} -eq 0 ]]; then
            RESULT=successful
        else
            RESULT=failed
        fi
        TIME_STRING=$(format_time "${START}" "$(date +%s)")
        {
            echo "android-${VERSION} | $(cd "${COMMON_FOLDER}" || die "wtf"; git kf origin/"$(git cb)") | Build ${RESULT} in ${TIME_STRING:l}\c"
            if [[ ${RESULT} = "successful" ]]; then
                if KERNEL_LOCATION=${OUT_FOLDER} bootk arm64 &>/dev/null; then
                    echo " | Boot successful\c"
                else
                    echo " | Boot failed\c"
                fi
            fi
            echo
            [[ -z ${DEBUG} && ( -n ${SHOW_NF_WARNINGS} || ${RESULT} = "failed" ) ]] && cat "${ERRORS}"
            echo
        } >> "${LOG}"
        rm "${ERRORS}"
    ) done

    MESSAGE="kernel/common build results: $(deldog "${LOG}")"

    tg_msg "${MESSAGE}"

    echo
    echo "${MESSAGE}"
    echo

    rm "${LOG}"

)}


# Build all kernel trees
function bldallk() {(
    TREE=linux lt
    TREE=linux-next lt
    kct
)}


# Build new LLVM/Clang/lld and test all kernel trees
function bldall() {(
    export TG=true
    bldusr && bldallk
)}


# Set up path to use CBL_BIN
function cbl_path() {
    case ${1} in
        "-s"|"--set") path_push "${CBL_BIN}" ;;
        "-u"|"--unset") export PATH=${PATH/${CBL_BIN}:/} ;;
    esac
}


# Function to test build-{binutils,llvm}.py in multiple Docker images
function bld_llvm_bntls_py() {(
    CCACHE_FOLDER=${CBL}/git/ccache
    LOG=$(mktemp); echo "Log: ${LOG}"
    SCRIPT=$(mktemp --suffix=.sh)
    TC_BLD=${CBL}/git/tc-build

    mkdir -p "${CCACHE_FOLDER}"
    cd "${TC_BLD}" || die "Could not move into ${TC_BLD}!"
    [[ -f build-llvm.py ]] || die "build-llvm.py script could not be found!"

    echo '#!/usr/env/bash

PACKAGES=( ccache clang cmake git python3 )

# Debian/Ubuntu
if command -v apt-get &>/dev/null; then
    PACKAGES+=( ca-certificates curl file gcc g++ make ninja-build texinfo zlib1g-dev )
    case "$(cat /etc/os-release)" in
        *buster*|*bionic*|*cosmic*|*disco*) PACKAGES+=( lld ) ;;
    esac
    apt-get update
    apt-get upgrade -y
    apt-get install --no-install-recommends -y "${PACKAGES[@]}"
# Fedora
elif command -v dnf &>/dev/null; then
    PACKAGES+=( gcc gcc-c++ lld make ninja-build zlib-devel )
    dnf update -y
    dnf install -y "${PACKAGES[@]}"
# Arch
elif command -v pacman &>/dev/null; then
    PACKAGES+=( base-devel lld ninja )
    pacman -Syyu --noconfirm
    pacman -S --noconfirm "${PACKAGES[@]}"
# OpenSUSE Tumbleweed
elif command -v zypper &>/dev/null; then
    PACKAGES+=( curl gcc gcc-c++ gzip lld make ninja tar zlib-devel )
    zypper -n up
    zypper -n in "${PACKAGES[@]}"
fi

ccache -M 30G
ccache --set-config=compression=true
ccache --set-config=compression_level=9
ccache --set-config=cache_dir=/ccache

git clone /'"${PWD##*/}"' /'"${PWD##*/}"'2 && cd /'"${PWD##*/}"'2

./build-binutils.py -t all || exit 1
CC=gcc ./build-llvm.py || exit 1
CC=clang ./build-llvm.py || exit 1

for FILE in clang ld.lld aarch64-linux-gnu-ld arm-linux-gnueabi-ld powerpc64le-linux-gnu-ld powerpc-linux-gnu-ld ld; do
    ./build/bin/${FILE} --version || exit 1
done' > "${SCRIPT}"

    for IMAGE in archlinux/base:latest \
                 debian:stable-slim \
                 debian:testing-slim \
                 debian:unstable-slim \
                 fedora:latest \
                 opensuse/tumbleweed:latest \
                 ubuntu:xenial \
                 ubuntu:latest \
                 ubuntu:rolling \
                 ubuntu:devel; do
        docker pull "${IMAGE}"
        docker_mount --interactive \
                     --mount type=bind,source="${CCACHE_FOLDER}",target=/ccache \
                     --mount type=bind,source="${SCRIPT}",target=/script.sh \
                     --rm \
                     --tty \
                     "${IMAGE}" bash /script.sh || { echo "${IMAGE} failed" >> "${LOG}"; continue; }
        echo "${IMAGE} successful" >> "${LOG}"
    done

    echo
    echo "Results:"
    cat "${LOG}"
    tg_msg "$(cat "${LOG}")"
    echo
)}


function yapf() {
    PYTHONPATH=${CBL}/git/yapf python3 ${CBL}/git/yapf/yapf -i -p "${@}"
}
# vi: filetype=zsh
