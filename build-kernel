#!/usr/bin/env bash
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# Copyright (C) 2017-2018 Nathan Chancellor
#
# Script to build a zImage from a kernel tree


# Source our universal functions script and macOS check
source common

# Echo to stderr
function errcho() {
    (>&2 echo "${@}")
}

# Start time
START=$(date +%s)

# Gather parameters
while [[ $# -ge 1 ]]; do
    case ${1} in
        # Architecture to build
        "-a"|"--arch")
            shift && enforce_value "$@"

            ARCH=${1} ;;

        # Use Clang for compiling the kernel
        "-c"|"--clang")

            CLANG=true ;;

        # Specify which Clang toolchain to use
        "-ct"|"--clang-toolchain")
            shift && enforce_value "$@"

            CLANG_TOOLCHAIN_FOLDER=${1} ;;

        # Config to build
        "-d"|"--defconfig")
            shift && enforce_value "$@"

            DEFCONFIG=${1} ;;

        # Show full compilation
        "-D"|"--debug")
            VERBOSITY=2 ;;

        # Kernel folder
        "-f"|"--folder")
            shift && enforce_value "$@"

            FOLDER=${1} ;;

        # Specify which GCC toolchain to use
        "-gt"|"--gcc-toolchain")
            shift && enforce_value "$@"

            GCC_TOOLCHAIN_FOLDER=${1} ;;

        # Just show if build was successful or not
        "-r"|"--show-only-result")
            SHOW_ONLY_RESULT=true ;;

        # Upload image to transfer.sh
        "-u"|"--upload")
            UPLOAD=true ;;

        # Show only warnings and errors during compilation
        "-w"|"--warnings")
            VERBOSITY=1 ;;

        # Compile with -Werror
        "-Werror")
            WERROR=true ;;
    esac

    shift
done

# Defaults
[[ -z ${ARCH} ]] && ARCH=arm64
[[ -z ${GCC_TOOLCHAIN_FOLDER} ]] && GCC_TOOLCHAIN_FOLDER=${TC_FOLDER}/aosp-gcc-${ARCH}

# Error out if defconfig wasn't supplied
[[ -z ${DEFCONFIG} ]] && die "Please supply a defconfig!"

# Set toolchains
if [[ ! -d ${GCC_TOOLCHAIN_FOLDER} ]]; then
    GCC_TOOLCHAIN_FOLDER=${TC_FOLDER}/${GCC_TOOLCHAIN_FOLDER}
    [[ ! -d ${GCC_TOOLCHAIN_FOLDER} ]] && die "Invalid GCC folder specified!"
fi
GCC_TOOLCHAIN=$(find "${GCC_TOOLCHAIN_FOLDER}/bin" \( -type f -o -type l \) -name '*-gcc' | head -n1)
[[ -z ${GCC_TOOLCHAIN} ]] && die "GCC toolchain could not be found!"

if [[ ${CLANG} ]]; then
    [[ -z ${CLANG_TOOLCHAIN_FOLDER} ]] && CLANG_TOOLCHAIN_FOLDER=${TC_FOLDER}/aosp-clang/clang-4053586
    if [[ ! -d ${CLANG_TOOLCHAIN_FOLDER} ]]; then
        CLANG_TOOLCHAIN_FOLDER=${TC_FOLDER}/${CLANG_TOOLCHAIN_FOLDER}
        [[ ! -d ${CLANG_TOOLCHAIN_FOLDER} ]] && die "Invalid Clang folder specified!"
    fi
    CLANG_TOOLCHAIN=${CLANG_TOOLCHAIN_FOLDER}/bin/clang
    [[ ! -f ${CLANG_TOOLCHAIN} ]] && die "Clang toolchain could not be found!"
fi

# Kernel make function
function kmake() {
    # Set make variable
    MAKE="make ${JOBS_FLAG} O=out ARCH=${ARCH}"

    if [[ ${CLANG} ]]; then
        PATH=${BIN_FOLDER}:${PATH} ${MAKE} CC="${CCACHE} ${CLANG_TOOLCHAIN}" \
                                           CLANG_TRIPLE=aarch64-linux-gnu- \
                                           CROSS_COMPILE="${GCC_TOOLCHAIN%gcc}" \
                                           HOSTCC="${CCACHE} ${CLANG_TOOLCHAIN}" \
                                           "$@"
    else
        PATH=${BIN_FOLDER}:${PATH} ${MAKE} CROSS_COMPILE="${CCACHE} ${GCC_TOOLCHAIN%gcc}" "$@"
    fi
}


# Basic build function
function build() {
    # Clean up from last compile
    rm -rf out && mkdir -p out

    # Build kernel image
    kmake "${DEFCONFIG}"
    if [[ ${WERROR} ]]; then
        ./scripts/config --file out/.config -e CC_WERROR
        kmake olddefconfig
    fi
    kmake
}


# Export version variable
function evv() {
    FILE=out/include/generated/compile.h
    export "$(grep "${1}" "${FILE}" | cut -d'"' -f1 | awk '{print $2}')"="$(grep "${1}" "${FILE}" | cut -d'"' -f2)"
}


# Show the version as if looking at "/proc/version"
function parse_version() {
    evv UTS_VERSION
    evv LINUX_COMPILE_BY
    evv LINUX_COMPILE_HOST
    evv LINUX_COMPILER
    VERSION=$(cat out/include/config/kernel.release)
    echo "Linux version ${VERSION} (${LINUX_COMPILE_BY}@${LINUX_COMPILE_HOST}) (${LINUX_COMPILER}) ${UTS_VERSION}"
}


# Report error if we aren't in a tree with a Makefile
if [[ -n ${FOLDER} ]]; then
    cd "${FOLDER}" || die "Folder requested doesn't exist!"
fi
[[ ! -f Makefile ]] && die "This must be run in a kernel tree!"

# Start hiding output
[[ ${SHOW_ONLY_RESULT} ]] && exec > /dev/null

# Show the base version we are making
header "BUILDING $(make CROSS_COMPILE="" kernelversion)"

# Show compilation based on flags
case ${VERBOSITY} in
    "2")
        build ;;
    "1")
        build |& ag --nocolor "error:|warning:" |& ag -v "which has unmet direct dependencies|choice value used outside its choice group" ;;
    *)
        build &> /dev/null ;;
esac

# Find final image
FINAL_IMAGE=$(find out -name 'Image.*-dtb')
[[ -z ${FINAL_IMAGE} ]] && FINAL_IMAGE=$(find out -name 'Image.*' | tail -1)

# Report success
END=$(date +%s)
if [[ -f ${FINAL_IMAGE} ]]; then
    echo
    errcho "${GRN}BUILT IN $(format_time "${START}" "${END}")${RST}"
    echo
    echo "${BOLD}IMAGE:${RST} ${FINAL_IMAGE}"
    echo
    echo "${BOLD}VERSION:${RST} $(parse_version)"
else
    >&2 die "Kernel build failed!"
fi

# Upload image if necessary
if [[ ${UPLOAD} ]]; then
    echo
    curl --upload-file "${FINAL_IMAGE}" https://transfer.sh/"${IMAGE}"
fi

# Alert of script end
echo "\n\a"
